---
AIGC:
    ContentProducer: Minimax Agent AI
    ContentPropagator: Minimax Agent AI
    Label: AIGC
    ProduceID: "00000000000000000000000000000000"
    PropagateID: "00000000000000000000000000000000"
    ReservedCode1: 3045022100b007fca5e8552d1c06714df4709b11fe67a4175b348bf158c59730925c7f2d7e0220485aacbcb659e912b1e6814dc5a671d4c228b6248c001a6102a08a75a4539120
    ReservedCode2: 3045022100a6acfd4dbadb3698451cba0a8025702b539fcd8eff77c580ab6cd055c6289c0d0220078b7c5d55d3e5137503f4a3a48ab0f7a983b64d107345564c858aa79b295a30
---

# 中望CAD动态块查寻插件故障排除指南

## 目录
1. [常见问题快速诊断](#常见问题快速诊断)
2. [安装问题](#安装问题)
3. [运行问题](#运行问题)
4. [功能问题](#功能问题)
5. [性能问题](#性能问题)
6. [网络问题](#网络问题)
7. [数据问题](#数据问题)
8. [高级故障排除](#高级故障排除)

---

## 常见问题快速诊断

### 问题诊断检查清单

在使用此指南前，请先执行以下基本检查：

#### 基础环境检查
- [ ] 中望CAD版本兼容（2020或更高版本）
- [ ] .NET Framework 4.8已安装
- [ ] 操作系统兼容性（Windows 10/11）
- [ ] 具有管理员权限
- [ ] 足够的磁盘空间（至少500MB）

#### 插件状态检查
- [ ] 插件文件完整且未损坏
- [ ] 插件已正确注册
- [ ] 配置文件存在且格式正确
- [ ] 日志文件可正常写入

#### 网络环境检查
- [ ] 网络连接正常
- [ ] 防火墙允许插件通信
- [ ] 代理服务器配置正确（如适用）

### 快速诊断工具

#### 诊断脚本
```powershell
# QuickDiagnostic.ps1
param(
    [string]$ComputerName = "localhost"
)

Write-Host "=== 中望CAD动态块查寻插件快速诊断 ===" -ForegroundColor Green
Write-Host "诊断时间: $(Get-Date)" -ForegroundColor Cyan
Write-Host ""

# 1. 系统环境检查
Write-Host "1. 系统环境检查" -ForegroundColor Yellow
$osInfo = Get-WmiObject -Class Win32_OperatingSystem
Write-Host "操作系统: $($osInfo.Caption) $($osInfo.Version)"
Write-Host "架构: $($osInfo.OSArchitecture)"
Write-Host "总内存: $([math]::Round($osInfo.TotalVisibleMemorySize/1MB,2)) GB"

# 2. .NET Framework检查
Write-Host ""
Write-Host "2. .NET Framework检查" -ForegroundColor Yellow
$dotnetVersions = Get-ChildItem "HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP" -Recurse | 
    Get-ItemProperty -Name version -ErrorAction SilentlyContinue | 
    Where { $_.PSChildName -Match "^(?!S)\p{L}"}
foreach ($version in $dotnetVersions) {
    Write-Host "  $($version.PSChildName): $($version.version)"
}

# 3. 中望CAD检查
Write-Host ""
Write-Host "3. 中望CAD检查" -ForegroundColor Yellow
$zwcadVersions = @(
    "HKLM:\SOFTWARE\WOW6432Node\Autodesk\AutoCAD\R24.0",
    "HKLM:\SOFTWARE\WOW6432Node\Autodesk\AutoCAD\R25.0",
    "HKLM:\SOFTWARE\WOW6432Node\Autodesk\AutoCAD\R26.0"
)

foreach ($regPath in $zwcadVersions) {
    if (Test-Path $regPath) {
        $version = Split-Path $regPath -Leaf
        $location = Get-ItemProperty $regPath -Name "AcadLocation" -ErrorAction SilentlyContinue
        if ($location) {
            Write-Host "  找到中望CAD $version: $($location.AcadLocation)"
        }
    }
}

# 4. 插件安装检查
Write-Host ""
Write-Host "4. 插件安装检查" -ForegroundColor Yellow
$pluginReg = "HKLM:\SOFTWARE\WOW6432Node\ZWDynLookup"
if (Test-Path $pluginReg) {
    $installPath = Get-ItemProperty $pluginReg -Name "InstallPath" -ErrorAction SilentlyContinue
    $version = Get-ItemProperty $pluginReg -Name "Version" -ErrorAction SilentlyContinue
    $installDate = Get-ItemProperty $pluginReg -Name "InstallDate" -ErrorAction SilentlyContinue
    
    Write-Host "  插件已安装: ✓"
    Write-Host "  安装路径: $($installPath.InstallPath)"
    Write-Host "  版本: $($version.Version)"
    Write-Host "  安装日期: $($installDate.InstallDate)"
    
    # 检查文件完整性
    if (Test-Path "$($installPath.InstallPath)\ZWDynLookup.dll") {
        Write-Host "  主文件完整: ✓"
    } else {
        Write-Host "  主文件缺失: ✗"
    }
} else {
    Write-Host "  插件未安装: ✗"
}

# 5. 服务检查
Write-Host ""
Write-Host "5. 服务检查" -ForegroundColor Yellow
$services = Get-Service | Where-Object { $_.Name -like "*ZWDynLookup*" }
if ($services) {
    foreach ($service in $services) {
        $status = if ($service.Status -eq "Running") { "✓" } else { "✗" }
        Write-Host "  $($service.DisplayName): $status ($($service.Status))"
    }
} else {
    Write-Host "  未找到插件服务"
}

# 6. 配置文件检查
Write-Host ""
Write-Host "6. 配置文件检查" -ForegroundColor Yellow
$configPaths = @(
    "$env:USERPROFILE\Documents\ZWDynLookup\config.xml",
    "C:\Program Files\ZWDynLookup\config.xml"
)

foreach ($configPath in $configPaths) {
    if (Test-Path $configPath) {
        Write-Host "  配置文件存在: $configPath"
        try {
            [xml]$config = Get-Content $configPath
            Write-Host "    格式正确: ✓"
        } catch {
            Write-Host "    格式错误: ✗"
        }
    }
}

# 7. 权限检查
Write-Host ""
Write-Host "7. 权限检查" -ForegroundColor Yellow
$currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
$principal = New-Object Security.Principal.WindowsPrincipal($currentUser)
if ($principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Write-Host "  当前用户: 管理员 ✓"
} else {
    Write-Host "  当前用户: 标准用户 ⚠"
}

# 8. 磁盘空间检查
Write-Host ""
Write-Host "8. 磁盘空间检查" -ForegroundColor Yellow
$drives = Get-WmiObject -Class Win32_LogicalDisk | Where-Object { $_.DriveType -eq 3 }
foreach ($drive in $drives) {
    $freeSpaceGB = [math]::Round($drive.FreeSpace/1GB, 2)
    $totalSpaceGB = [math]::Round($drive.Size/1GB, 2)
    $usagePercent = [math]::Round((($totalSpaceGB - $freeSpaceGB) / $totalSpaceGB) * 100, 1)
    
    $status = if ($freeSpaceGB -gt 1) { "✓" } else { "✗" }
    Write-Host "  驱动器 $($drive.DeviceID): $status ($usagePercent% 使用, $freeSpaceGB GB 可用)"
}

Write-Host ""
Write-Host "=== 诊断完成 ===" -ForegroundColor Green
```

#### 自动修复脚本
```powershell
# AutoRepair.ps1
Write-Host "开始自动修复..." -ForegroundColor Yellow

# 1. 重新注册插件
Write-Host "1. 重新注册插件..." -ForegroundColor Yellow
$pluginPath = "C:\Program Files\ZWDynLookup\ZWDynLookup.dll"
if (Test-Path $pluginPath) {
    & "regsvr32.exe" /s $pluginPath
    Write-Host "插件重新注册完成"
} else {
    Write-Host "插件文件不存在，请重新安装"
}

# 2. 修复配置文件
Write-Host "2. 修复配置文件..." -ForegroundColor Yellow
$configDir = "$env:USERPROFILE\Documents\ZWDynLookup"
if (!(Test-Path $configDir)) {
    New-Item -ItemType Directory -Path $configDir -Force
}

$configFile = "$configDir\config.xml"
$defaultConfig = @"
<?xml version="1.0" encoding="utf-8"?>
<Configuration>
  <General>
    <InstallPath>C:\Program Files\ZWDynLookup</InstallPath>
    <ConfigPath>$configDir</ConfigPath>
    <LogLevel>Info</LogLevel>
    <Language>zh-CN</Language>
    <AutoSave>true</AutoSave>
  </General>
  <UI>
    <Theme>Light</Theme>
    <ShowTooltips>true</ShowTooltips>
    <ConfirmActions>true</ConfirmActions>
  </UI>
  <Performance>
    <MaxParameters>50</MaxParameters>
    <MaxSelectionSets>20</MaxSelectionSets>
  </Performance>
</Configuration>
"@

if (!(Test-Path $configFile)) {
    $defaultConfig | Out-File $configFile -Encoding UTF8
    Write-Host "配置文件已创建"
} else {
    try {
        [xml]$config = Get-Content $configFile
        Write-Host "配置文件格式正确"
    } catch {
        $defaultConfig | Out-File $configFile -Encoding UTF8
        Write-Host "配置文件已修复"
    }
}

# 3. 清理临时文件
Write-Host "3. 清理临时文件..." -ForegroundColor Yellow
$tempDir = "$configDir\Temp"
if (Test-Path $tempDir) {
    Get-ChildItem $tempDir | Remove-Item -Force -Recurse
    Write-Host "临时文件已清理"
}

# 4. 重置用户设置
Write-Host "4. 重置用户设置..." -ForegroundColor Yellow
$settingsFile = "$configDir\user_settings.json"
if (Test-Path $settingsFile) {
    Remove-Item $settingsFile -Force
    Write-Host "用户设置已重置"
}

Write-Host "自动修复完成！" -ForegroundColor Green
Write-Host "建议重启中望CAD后重新测试插件功能" -ForegroundColor Cyan
```

---

## 安装问题

### 问题：安装程序无法运行

**症状：**
- 双击安装程序无反应
- 提示"不是有效的Win32应用程序"
- 出现"应用程序无法正常启动"错误

**可能原因：**
1. 安装包损坏或不完整
2. 目标系统架构不匹配（32位/64位）
3. 缺少必要的运行库
4. 权限不足

**解决方案：**

#### 检查系统兼容性
```batch
:: 检查系统架构
wmic computersystem get systemtype
:: 应显示 "x64-based PC" 表示64位系统

:: 检查Windows版本
ver
:: Windows 10/11 应该是 10.0.xxxx 或更高
```

#### 验证安装包完整性
```powershell
# 验证安装包
$installerPath = "ZWDynLookup_Setup.exe"
$expectedSize = 15728640  # 15MB预期大小

if (Test-Path $installerPath) {
    $actualSize = (Get-Item $installerPath).Length
    if ($actualSize -eq $expectedSize) {
        Write-Host "安装包大小正确: $actualSize 字节"
    } else {
        Write-Host "警告: 安装包大小异常 - 预期: $expectedSize, 实际: $actualSize"
    }
    
    # 检查数字签名
    $signature = Get-AuthenticodeSignature $installerPath
    if ($signature.Status -eq "Valid") {
        Write-Host "数字签名有效"
    } else {
        Write-Host "警告: 数字签名无效或过期"
    }
} else {
    Write-Error "安装包文件不存在"
}
```

#### 以兼容模式安装
1. 右键点击安装程序
2. 选择"属性" → "兼容性"选项卡
3. 勾选"以兼容模式运行这个程序"
4. 选择"Windows 8"兼容模式
5. 勾选"以管理员身份运行此程序"
6. 点击"确定"后重新运行安装程序

### 问题：安装过程中出现权限错误

**症状：**
- 提示"访问被拒绝"
- 无法写入注册表
- 无法创建文件夹

**解决方案：**
```powershell
# 以管理员权限运行PowerShell
# 然后执行以下脚本

# 1. 获取当前用户SID
$currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
$userSID = $currentUser.User.Value

# 2. 检查管理员权限
$isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
if (-not $isAdmin) {
    Write-Error "需要管理员权限运行此脚本"
    exit 1
}

# 3. 设置安装目录权限
$installDir = "C:\Program Files\ZWDynLookup"
New-Item -ItemType Directory -Path $installDir -Force

# 获取当前用户并设置权限
$currentUserName = $env:USERNAME
icacls $installDir /grant "$currentUserName:(OI)(CI)F" /T

# 4. 设置注册表权限
$regPath = "HKLM:\SOFTWARE\WOW6432Node\ZWDynLookup"
if (!(Test-Path $regPath)) {
    New-Item -Path $regPath -Force
}

# 5. 设置配置目录权限
$configDir = "$env:USERPROFILE\Documents\ZWDynLookup"
New-Item -ItemType Directory -Path $configDir -Force
icacls $configDir /grant "$currentUserName:(OI)(CI)F" /T

Write-Host "权限设置完成"
```

### 问题：依赖组件缺失

**症状：**
- 提示".NET Framework版本不兼容"
- 提示"缺少Visual C++运行库"
- 安装程序自动退出

**解决方案：**

#### 检查和安装.NET Framework
```powershell
# 检查.NET Framework 4.8
$netFramework = Get-ChildItem "HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full\" | 
    Get-ItemPropertyValue -Name Release -ErrorAction SilentlyContinue

if ($netFramework -ge 528040) {
    Write-Host ".NET Framework 4.8或更高版本已安装"
} else {
    Write-Host ".NET Framework 4.8未安装或版本过低"
    Write-Host "请从以下链接下载并安装："
    Write-Host "https://dotnet.microsoft.com/download/dotnet-framework/net48"
}
```

#### 安装Visual C++运行库
```batch
:: 检查Visual C++运行库
reg query "HKLM\SOFTWARE\Microsoft\VisualStudio\14.0\VC\Runtimes\x64" /v Version

:: 如果未安装，可以从以下链接下载：
:: https://docs.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist
:: 或运行以下命令（需要下载安装包）
:: vcredist_x64.exe /quiet
```

---

## 运行问题

### 问题：插件命令无法识别

**症状：**
- 输入`ZWBPARAMETER`提示"未知命令"
- 命令自动补全不显示插件命令
- 所有插件命令都提示"未定义"

**诊断步骤：**
```powershell
# 1. 检查插件加载状态
Write-Host "检查插件加载状态..." -ForegroundColor Yellow

# 检查注册表中的插件注册信息
$pluginReg = "HKLM:\SOFTWARE\WOW6432Node\ZWDynLookup"
if (Test-Path $pluginReg) {
    Write-Host "插件注册信息存在"
    Get-ItemProperty $pluginReg | Format-List
} else {
    Write-Host "插件注册信息不存在"
}

# 2. 检查插件文件
$pluginPath = "C:\Program Files\ZWDynLookup\ZWDynLookup.dll"
if (Test-Path $pluginPath) {
    Write-Host "插件文件存在: $pluginPath"
    $fileInfo = Get-Item $pluginPath
    Write-Host "文件大小: $($fileInfo.Length) 字节"
    Write-Host "最后修改: $($fileInfo.LastWriteTime)"
} else {
    Write-Host "插件文件不存在: $pluginPath"
}

# 3. 检查中望CAD插件目录
$cadPluginDirs = @(
    "$env:APPDATA\Autodesk\ApplicationPlugins",
    "$env:ALLUSERSPROFILE\Autodesk\ApplicationPlugins",
    "$env:PROGRAMFILES\Autodesk\ApplicationPlugins"
)

foreach ($dir in $cadPluginDirs) {
    if (Test-Path $dir) {
        Write-Host "检查CAD插件目录: $dir"
        $plugins = Get-ChildItem $dir -Filter "*.dll" -Recurse | Where-Object { $_.Name -like "*ZWDynLookup*" }
        if ($plugins) {
            Write-Host "找到插件文件:"
            $plugins | ForEach-Object { Write-Host "  $($_.FullName)" }
        }
    }
}
```

**解决方案：**

#### 手动加载插件
1. 在中望CAD命令行输入：`APPLOAD`
2. 导航到插件安装目录：`C:\Program Files\ZWDynLookup`
3. 选择`ZWDynLookup.dll`文件
4. 点击"加载"按钮
5. 如果成功加载，应该会显示"ZWDynLookup.dll 已加载"

#### 重新注册插件
```powershell
# 重新注册插件
$pluginPath = "C:\Program Files\ZWDynLookup\ZWDynLookup.dll"

if (Test-Path $pluginPath) {
    # 注销插件
    & "regsvr32.exe" /u /s $pluginPath
    
    # 等待一秒
    Start-Sleep -Seconds 1
    
    # 重新注册插件
    & "regsvr32.exe" /s $pluginPath
    
    Write-Host "插件重新注册完成"
} else {
    Write-Error "插件文件不存在"
}
```

### 问题：插件界面显示异常

**症状：**
- 对话框布局错乱
- 文字显示乱码
- 按钮或控件不可见
- 界面卡死或响应缓慢

**诊断步骤：**
```powershell
# 检查UI相关组件
Write-Host "检查UI组件..." -ForegroundColor Yellow

# 1. 检查WPF相关组件
$wpfTests = @(
    @{ Name = "PresentationCore"; Assembly = "PresentationCore.dll" },
    @{ Name = "PresentationFramework"; Assembly = "PresentationFramework.dll" },
    @{ Name = "WindowsBase"; Assembly = "WindowsBase.dll" }
)

foreach ($test in $wpfTests) {
    try {
        $assembly = [System.Reflection.Assembly]::LoadWithPartialName($test.Assembly)
        if ($assembly) {
            Write-Host "$($test.Name): ✓ 已加载"
        } else {
            Write-Host "$($test.Name): ✗ 未找到"
        }
    } catch {
        Write-Host "$($test.Name): ✗ 加载失败 - $($_.Exception.Message)"
    }
}

# 2. 检查显卡驱动
Write-Host ""
Write-Host "检查显卡信息..." -ForegroundColor Yellow
$graphicsCards = Get-WmiObject -Class Win32_VideoController | Select-Object Name, DriverVersion, Status
foreach ($card in $graphicsCards) {
    Write-Host "显卡: $($card.Name)"
    Write-Host "驱动版本: $($card.DriverVersion)"
    Write-Host "状态: $($card.Status)"
    Write-Host ""
}
```

**解决方案：**

#### 修复显示问题
1. **更新显卡驱动**
   - 访问显卡制造商官网下载最新驱动
   - 或者使用Windows Update自动更新

2. **调整显示设置**
   ```
   1. 右键点击桌面 → 选择"显示设置"
   2. 确保缩放设置为100%（推荐）
   3. 如果使用高DPI显示，可能需要：
      - 右键插件快捷方式
      - 属性 → 兼容性 → 更改高DPI设置
      - 勾选"替代高DPI缩放行为"
   ```

3. **重置UI配置**
   ```xml
   <!-- 重置UI配置到config.xml -->
   <UI>
     <Theme>Light</Theme>
     <ShowTooltips>true</ShowTooltips>
     <ConfirmActions>true</ConfirmActions>
     <WindowPlacement>
       <X>100</X>
       <Y>100</Y>
       <Width>800</Width>
       <Height>600</Height>
       <Restore>true</Restore>
     </WindowPlacement>
   </UI>
   ```

#### 清理UI缓存
```powershell
# 清理UI缓存
$cacheDir = "$env:LOCALAPPDATA\ZWDynLookup\UI_Cache"
if (Test-Path $cacheDir) {
    Remove-Item $cacheDir -Recurse -Force
    Write-Host "UI缓存已清理"
}

# 重置用户界面设置
$settingsFile = "$env:USERPROFILE\Documents\ZWDynLookup\ui_settings.json"
if (Test-Path $settingsFile) {
    Remove-Item $settingsFile -Force
    Write-Host "UI设置已重置"
}
```

---

## 功能问题

### 问题：查寻参数创建失败

**症状：**
- 执行`ZWBPARAMETER`命令后程序崩溃
- 参数对话框无法打开
- 参数创建过程中出现错误

**诊断步骤：**
```csharp
// 检查参数创建相关组件
public void DiagnoseParameterCreation()
{
    try
    {
        // 1. 检查当前文档状态
        var doc = PluginEntry.GetActiveDocument();
        if (doc == null)
        {
            Log("错误: 没有活动的CAD文档");
            return;
        }
        
        // 2. 检查是否在块编辑器中
        if (!doc.Editor.IsInBlockEditor)
        {
            Log("警告: 当前不在块编辑器中，参数创建可能失败");
        }
        
        // 3. 检查参数管理器
        var parameterManager = new ParameterPointManager(doc.Database);
        var existingParameters = parameterManager.GetAllParameters();
        Log($"当前参数数量: {existingParameters.Count}");
        
        // 4. 检查权限
        var transaction = doc.Database.TransactionManager.StartTransaction();
        try
        {
            var blockTable = transaction.GetObject(doc.Database.BlockTableId, OpenMode.ForRead) as BlockTable;
            if (blockTable != null)
            {
                Log($"块表访问正常，记录数: {blockTable.Count}");
            }
        }
        finally
        {
            transaction.Dispose();
        }
    }
    catch (Exception ex)
    {
        Log($"参数创建诊断失败: {ex.Message}");
    }
}
```

**解决方案：**

#### 检查块编辑器状态
```csharp
// 确保在块编辑器中创建参数
public bool EnsureBlockEditor()
{
    var doc = PluginEntry.GetActiveDocument();
    if (doc == null) return false;
    
    if (!doc.Editor.IsInBlockEditor)
    {
        // 尝试进入块编辑器
        doc.Editor.ToggleBlockEditor();
        
        // 检查是否成功
        return doc.Editor.IsInBlockEditor;
    }
    
    return true;
}
```

#### 验证参数数据
```csharp
// 验证参数创建数据
public ValidationResult ValidateParameterData(string name, string label, string description)
{
    var result = new ValidationResult();
    
    // 检查参数名称
    if (string.IsNullOrWhiteSpace(name))
    {
        result.AddError("参数名称不能为空");
    }
    
    if (name.Length > 255)
    {
        result.AddError("参数名称过长");
    }
    
    // 检查特殊字符
    var invalidChars = Path.GetInvalidFileNameChars();
    if (name.Any(c => invalidChars.Contains(c)))
    {
        result.AddError("参数名称包含无效字符");
    }
    
    // 检查名称唯一性
    var parameterManager = new ParameterPointManager(PluginEntry.GetActiveDocument()?.Database);
    if (parameterManager.FindParameterByName(name) != null)
    {
        result.AddError("参数名称已存在");
    }
    
    return result;
}
```

### 问题：查寻动作无法触发

**症状：**
- 查寻动作创建后无法响应用户操作
- 点击夹点没有查寻菜单显示
- 动作关联的对象没有变化

**诊断步骤：**
```powershell
# 诊断查寻动作问题
Write-Host "诊断查寻动作问题..." -ForegroundColor Yellow

# 1. 检查动作与参数的关联
$testScript = @"
function Test-ActionAssociation {
    param([string]$BlockName)
    
    try {
        # 在CAD中执行测试命令
        $command = @'
BE
OPENBLOCK
$BlockName
BACTIONTOOL
L
SELECTPARAMETER
SELECTOBJECTS
ESC
ESC
BE
'@
        
        # 这里需要在CAD环境中运行
        return $true
    }
    catch {
        Write-Host "动作关联测试失败: $($_.Exception.Message)"
        return $false
    }
}
"@
```

**解决方案：**

#### 重新建立动作关联
```csharp
// 重新建立查寻动作与参数的关联
public bool ReestablishActionAssociation(string parameterName, string actionName)
{
    try
    {
        var doc = PluginEntry.GetActiveDocument();
        if (doc == null) return false;
        
        using (var trans = doc.Database.TransactionManager.StartTransaction())
        {
            // 查找参数
            var parameterManager = new ParameterPointManager(doc.Database);
            var parameter = parameterManager.FindParameterByName(parameterName);
            if (parameter == null)
            {
                Log($"参数 {parameterName} 未找到");
                return false;
            }
            
            // 查找动作
            var actionCreator = new LookupActionCreator(doc.Database);
            var actions = actionCreator.GetActionsByParameter(parameter.Id);
            var targetAction = actions.FirstOrDefault(a => a.ActionName == actionName);
            
            if (targetAction == null)
            {
                Log($"动作 {actionName} 未找到");
                return false;
            }
            
            // 重新关联参数和动作
            targetAction.ParameterId = parameter.Id;
            targetAction.IsActive = true;
            
            trans.Commit();
            Log($"动作关联已重建");
            return true;
        }
    }
    catch (Exception ex)
    {
        Log($"重建动作关联失败: {ex.Message}");
        return false;
    }
}
```

#### 验证查寻表数据
```csharp
// 验证查寻表数据完整性
public ValidationResult ValidateLookupTableData()
{
    var result = new ValidationResult();
    
    try
    {
        var doc = PluginEntry.GetActiveDocument();
        if (doc == null)
        {
            result.AddError("没有活动的文档");
            return result;
        }
        
        // 检查查寻表对象
        var lookupTables = GetLookupTables(doc.Database);
        foreach (var table in lookupTables)
        {
            // 验证表格数据
            if (table.Rows.Count == 0)
            {
                result.AddWarning($"查寻表 {table.Name} 没有数据行");
            }
            
            // 验证列定义
            if (table.Columns.Count == 0)
            {
                result.AddError($"查寻表 {table.Name} 没有定义列");
            }
            
            // 验证数据完整性
            foreach (var row in table.Rows)
            {
                if (string.IsNullOrEmpty(row.GetValue("InputProperty")))
                {
                    result.AddError($"查寻表 {table.Name} 包含空输入特性值");
                }
            }
        }
    }
    catch (Exception ex)
    {
        result.AddError($"查寻表验证失败: {ex.Message}");
    }
    
    return result;
}
```

---

## 性能问题

### 问题：插件运行缓慢

**症状：**
- 命令响应时间过长
- 对话框加载缓慢
- 内存占用持续增长

**性能监控脚本：**
```powershell
# PerformanceMonitor.ps1
Write-Host "=== 插件性能监控 ===" -ForegroundColor Green

# 1. 监控插件进程
Write-Host "1. 插件进程信息" -ForegroundColor Yellow
$pluginProcesses = Get-Process | Where-Object { $_.ProcessName -like "*ZWDynLookup*" -or $_.ProcessName -like "*ZwCAD*" }
foreach ($process in $pluginProcesses) {
    $cpuPercent = $process.CPU
    $memoryMB = [math]::Round($process.WorkingSet64 / 1MB, 2)
    $threadCount = $process.Threads.Count
    $handleCount = $process.Handles.Count
    
    Write-Host "进程: $($process.ProcessName)"
    Write-Host "  CPU时间: $cpuPercent 秒"
    Write-Host "  内存使用: $memoryMB MB"
    Write-Host "  线程数: $threadCount"
    Write-Host "  句柄数: $handleCount"
    Write-Host ""
}

# 2. 监控CAD进程详细信息
Write-Host "2. CAD进程详细信息" -ForegroundColor Yellow
$cadProcess = Get-Process ZwCAD -ErrorAction SilentlyContinue
if ($cadProcess) {
    $startTime = $cadProcess.StartTime
    $uptime = (Get-Date) - $startTime
    Write-Host "启动时间: $startTime"
    Write-Host "运行时间: $($uptime.ToString('hh\:mm\:ss'))"
    
    # 监控内存增长
    $currentMemory = [math]::Round($cadProcess.WorkingSet64 / 1MB, 2)
    Write-Host "当前内存: $currentMemory MB"
    
    # 检查是否存在内存泄漏
    if (Test-Path "$env:TEMP\ZWDynLookup_MemoryBaseline.txt") {
        $baseline = Get-Content "$env:TEMP\ZWDynLookup_MemoryBaseline.txt" | ConvertFrom-Json
        $memoryIncrease = $currentMemory - $baseline.MemoryMB
        
        if ($memoryIncrease -gt 100) {
            Write-Host "警告: 内存增长超过100MB，可能存在内存泄漏" -ForegroundColor Red
        } else {
            Write-Host "内存使用正常，增长: $memoryIncrease MB" -ForegroundColor Green
        }
    } else {
        # 保存基准数据
        $baselineData = @{ 
            Timestamp = Get-Date 
            MemoryMB = $currentMemory 
        }
        $baselineData | ConvertTo-Json | Out-File "$env:TEMP\ZWDynLookup_MemoryBaseline.txt"
        Write-Host "内存基准数据已保存" -ForegroundColor Cyan
    }
} else {
    Write-Host "CAD进程未找到" -ForegroundColor Red
}

# 3. 监控文件句柄
Write-Host "3. 插件文件句柄监控" -ForegroundColor Yellow
$handleExe = "$env:ProgramFiles\Sysinternals\handle.exe"
if (Test-Path $handleExe) {
    & $handleExe -a -p ZwCAD | Where-Object { $_ -like "*ZWDynLookup*" } | ForEach-Object {
        Write-Host "  $_"
    }
} else {
    Write-Host "Handle.exe 未安装，跳过文件句柄监控"
}

# 4. 监控线程状态
Write-Host "4. 插件线程监控" -ForegroundColor Yellow
if ($cadProcess) {
    $threads = Get-WmiObject -Class Win32_Thread | Where-Object { $_.ProcessHandle -eq $cadProcess.Id }
    $threadCount = $threads.Count
    $blockedThreads = ($threads | Where-Object { $_.ThreadState -eq 5 }).Count
    
    Write-Host "总线程数: $threadCount"
    Write-Host "阻塞线程数: $blockedThreads"
    
    if ($blockedThreads -gt 0) {
        Write-Host "警告: 检测到 $blockedThreads 个阻塞线程" -ForegroundColor Red
    }
}

Write-Host ""
Write-Host "=== 性能监控完成 ===" -ForegroundColor Green
```

**性能优化建议：**

#### 内存优化
```csharp
// 内存使用优化
public class MemoryOptimizer
{
    public static void OptimizeMemoryUsage()
    {
        // 强制垃圾回收
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        
        // 清理未使用的资源
        ClearUnusedResources();
        
        // 压缩内存
        SetProcessWorkingSetSize(Process.GetCurrentProcess().Handle, 
            UIntPtr.MinValue, UIntPtr.MaxValue);
    }
    
    private static void ClearUnusedResources()
    {
        // 清理临时文件
        var tempDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), 
            "ZWDynLookup", "Temp");
        if (Directory.Exists(tempDir))
        {
            Directory.Delete(tempDir, true);
            Directory.CreateDirectory(tempDir);
        }
        
        // 清理缓存
        ClearCache();
    }
}
```

#### 性能配置优化
```xml
<!-- 优化性能配置 -->
<Performance>
  <EnableCaching>true</EnableCaching>
  <CacheSize>50</CacheSize>
  <MaxParameters>30</MaxParameters>
  <MaxSelectionSets>15</MaxSelectionSets>
  <EnableAsyncProcessing>true</EnableAsyncProcessing>
  <BatchOperationSize>10</BatchOperationSize>
  <AutoCleanupInterval>300</AutoCleanupInterval>
  <MemoryThreshold>500</MemoryThreshold>
  <DisableAnimations>true</DisableAnimations>
  <EnableProfiling>false</EnableProfiling>
</Performance>
```

---

## 网络问题

### 问题：无法连接到更新服务器

**症状：**
- 自动更新检查失败
- 配置文件下载失败
- 许可证验证失败

**网络诊断脚本：**
```powershell
# NetworkDiagnostic.ps1
Write-Host "=== 网络连接诊断 ===" -ForegroundColor Green

# 1. 检查基本网络连接
Write-Host "1. 基本网络连接" -ForegroundColor Yellow
$connection = Test-NetConnection -ComputerName "8.8.8.8" -Port 53 -InformationLevel Detailed
if ($connection.TcpTestSucceeded) {
    Write-Host "基本网络连接: ✓ 正常"
} else {
    Write-Host "基本网络连接: ✗ 失败"
}

# 2. 检查DNS解析
Write-Host ""
Write-Host "2. DNS解析测试" -ForegroundColor Yellow
try {
    $dnsResult = Resolve-DnsName "zwdynlookup.com" -ErrorAction Stop
    Write-Host "DNS解析成功:"
    $dnsResult | ForEach-Object { Write-Host "  $($_.Name) -> $($_.IPAddress)" }
} catch {
    Write-Host "DNS解析失败: $($_.Exception.Message)" -ForegroundColor Red
}

# 3. 检查HTTPS连接
Write-Host ""
Write-Host "3. HTTPS连接测试" -ForegroundColor Yellow
$urls = @(
    "https://updates.zwdynlookup.com",
    "https://config.zwdynlookup.com",
    "https://license.zwdynlookup.com"
)

foreach ($url in $urls) {
    try {
        $response = Invoke-WebRequest -Uri $url -Method Head -TimeoutSec 30 -UseBasicParsing
        Write-Host "$url : ✓ ($($response.StatusCode))"
    } catch {
        Write-Host "$url : ✗ ($($_.Exception.Message))" -ForegroundColor Red
    }
}

# 4. 检查代理设置
Write-Host ""
Write-Host "4. 代理设置检查" -ForegroundColor Yellow
$proxySettings = @(
    "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings",
    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings"
)

foreach ($regPath in $proxySettings) {
    if (Test-Path $regPath) {
        $proxyEnabled = Get-ItemProperty $regPath -Name "ProxyEnable" -ErrorAction SilentlyContinue
        $proxyServer = Get-ItemProperty $regPath -Name "ProxyServer" -ErrorAction SilentlyContinue
        
        if ($proxyEnabled.ProxyEnable -eq 1) {
            Write-Host "代理设置: 已启用"
            Write-Host "代理服务器: $($proxyServer.ProxyServer)"
        } else {
            Write-Host "代理设置: 未启用"
        }
    }
}

# 5. 检查防火墙
Write-Host ""
Write-Host "5. 防火墙状态检查" -ForegroundColor Yellow
$firewallProfiles = Get-NetFirewallProfile
foreach ($profile in $firewallProfiles) {
    $status = if ($profile.Enabled) { "已启用" } else { "已禁用" }
    Write-Host "$($profile.Name): $status"
}

# 6. 生成网络配置建议
Write-Host ""
Write-Host "6. 网络配置建议" -ForegroundColor Cyan
Write-Host "如果遇到网络连接问题，请尝试以下解决方案："
Write-Host ""
Write-Host "代理配置:"
Write-Host "  - 确保代理服务器设置正确"
Write-Host "  - 将 zwdynlookup.com 添加到代理白名单"
Write-Host "  - 检查代理认证设置"
Write-Host ""
Write-Host "防火墙配置:"
Write-Host "  - 允许程序通过Windows防火墙"
Write-Host "  - 开放以下端口：80, 443, 8080"
Write-Host ""
Write-Host "网络诊断:"
Write-Host "  - 尝试使用其他网络连接"
Write-Host "  - 联系网络管理员"
Write-Host "  - 检查DNS设置"

Write-Host ""
Write-Host "=== 网络诊断完成 ===" -ForegroundColor Green
```

**解决方案：**

#### 配置代理设置
```xml
<!-- 代理配置示例 -->
<Network>
  <ProxyServer>proxy.company.com</ProxyServer>
  <ProxyPort>8080</ProxyPort>
  <ProxyUser>username</ProxyUser>
  <ProxyPassword>encrypted_password</ProxyPassword>
  <BypassList>
    <Domain>localhost</Domain>
    <Domain>127.0.0.1</Domain>
    <Domain>*.local</Domain>
  </BypassList>
  <Timeout>30000</Timeout>
  <RetryCount>3</RetryCount>
</Network>
```

#### 网络连接测试代码
```csharp
// 网络连接测试
public class NetworkTester
{
    private readonly HttpClient _httpClient;
    
    public NetworkTester()
    {
        _httpClient = new HttpClient();
        _httpClient.Timeout = TimeSpan.FromSeconds(30);
        
        // 配置代理
        var proxyConfig = LoadProxyConfiguration();
        if (!string.IsNullOrEmpty(proxyConfig.Server))
        {
            var proxy = new WebProxy($"{proxyConfig.Server}:{proxyConfig.Port}");
            if (!string.IsNullOrEmpty(proxyConfig.Username))
            {
                proxy.Credentials = new NetworkCredential(proxyConfig.Username, proxyConfig.Password);
            }
            _httpClient = new HttpClient(new HttpClientHandler { Proxy = proxy });
        }
    }
    
    public async Task<bool> TestConnectionAsync(string url)
    {
        try
        {
            var response = await _httpClient.GetAsync(url);
            return response.IsSuccessStatusCode;
        }
        catch (Exception ex)
        {
            Log($"网络连接测试失败: {ex.Message}");
            return false;
        }
    }
    
    public async Task<bool> TestLicenseServerAsync()
    {
        const string licenseServer = "https://license.zwdynlookup.com/api/ping";
        return await TestConnectionAsync(licenseServer);
    }
}
```

---

## 数据问题

### 问题：配置文件损坏

**症状：**
- 插件启动时出现配置错误
- 设置无法保存
- 对话框显示异常

**配置文件修复脚本：**
```powershell
# ConfigRepair.ps1
Write-Host "开始配置文件修复..." -ForegroundColor Yellow

$configDir = "$env:USERPROFILE\Documents\ZWDynLookup"
$configFile = "$configDir\config.xml"
$backupFile = "$configDir\config_backup.xml"

# 1. 创建配置备份
Write-Host "1. 创建配置备份..." -ForegroundColor Yellow
if (Test-Path $configFile) {
    Copy-Item $configFile $backupFile -Force
    Write-Host "配置备份已创建: $backupFile"
} else {
    Write-Host "配置文件不存在，创建新配置" -ForegroundColor Cyan
}

# 2. 验证配置文件格式
Write-Host "2. 验证配置文件格式..." -ForegroundColor Yellow
function Test-XmlFile {
    param([string]$Path)
    
    try {
        [xml]$xml = Get-Content $Path -ErrorAction Stop
        Write-Host "XML格式正确"
        return $true
    }
    catch {
        Write-Host "XML格式错误: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

$isValid = Test-XmlFile $configFile

# 3. 修复配置文件
if (-not $isValid) {
    Write-Host "3. 修复配置文件..." -ForegroundColor Yellow
    
    $defaultConfig = @"
<?xml version="1.0" encoding="utf-8"?>
<Configuration>
  <General>
    <InstallPath>C:\Program Files\ZWDynLookup</InstallPath>
    <ConfigPath>$configDir</ConfigPath>
    <LogLevel>Info</LogLevel>
    <Language>zh-CN</Language>
    <AutoSave>true</AutoSave>
    <AutoUpdate>true</AutoUpdate>
    <UpdateServer>https://updates.zwdynlookup.com</UpdateServer>
  </General>
  
  <UI>
    <Theme>Light</Theme>
    <ShowTooltips>true</ShowTooltips>
    <ConfirmActions>true</ConfirmActions>
    <ShowAdvancedOptions>false</ShowAdvancedOptions>
    <WindowPlacement>
      <X>100</X>
      <Y>100</Y>
      <Width>800</Width>
      <Height>600</Height>
      <Restore>true</Restore>
    </WindowPlacement>
  </UI>
  
  <Performance>
    <MaxParameters>50</MaxParameters>
    <MaxSelectionSets>20</MaxSelectionSets>
    <MaxUndoLevels>100</MaxUndoLevels>
    <EnableCaching>true</EnableCaching>
    <CacheSize>100</CacheSize>
    <AutoCleanupInterval>3600</AutoCleanupInterval>
    <MemoryThreshold>500</MemoryThreshold>
  </Performance>
  
  <Network>
    <ProxyServer></ProxyServer>
    <ProxyPort>8080</ProxyPort>
    <ProxyUser></ProxyUser>
    <Timeout>30000</Timeout>
    <RetryCount>3</RetryCount>
  </Network>
  
  <Security>
    <EnableEncryption>true</EnableEncryption>
    <CertificatePath></CertificatePath>
    <AllowedDomains>
      <Domain>*.zwdynlookup.com</Domain>
      <Domain>*.zwcad.com</Domain>
    </AllowedDomains>
  </Security>
  
  <Logging>
    <LogFile>$configDir\Plugin.log</LogFile>
    <LogMaxSize>10MB</LogMaxSize>
    <LogBackupCount>5</LogBackupCount>
    <EnableConsoleLog>false</EnableConsoleLog>
    <EnableFileLog>true</EnableFileLog>
  </Logging>
</Configuration>
"@
    
    # 写入默认配置
    $defaultConfig | Out-File $configFile -Encoding UTF8
    Write-Host "配置文件已重置为默认配置"
    
    # 验证修复结果
    if (Test-XmlFile $configFile) {
        Write-Host "配置文件修复成功" -ForegroundColor Green
    } else {
        Write-Host "配置文件修复失败" -ForegroundColor Red
    }
} else {
    Write-Host "配置文件格式正确，无需修复" -ForegroundColor Green
}

# 4. 清理损坏的缓存文件
Write-Host "4. 清理缓存文件..." -ForegroundColor Yellow
$cacheDirs = @(
    "$configDir\Cache",
    "$configDir\Temp",
    "$env:LOCALAPPDATA\ZWDynLookup\UI_Cache"
)

foreach ($cacheDir in $cacheDirs) {
    if (Test-Path $cacheDir) {
        Remove-Item $cacheDir -Recurse -Force
        Write-Host "已清理: $cacheDir"
    }
}

# 5. 重建用户设置
Write-Host "5. 重建用户设置..." -ForegroundColor Yellow
$userSettingsFile = "$configDir\user_settings.json"
if (Test-Path $userSettingsFile) {
    Remove-Item $userSettingsFile -Force
}

$defaultSettings = @{
    lastUsedCommands = @()
    windowSettings = @{}
    preferences = @{
        showWelcomeDialog = $true
        enableAutoSave = $true
        confirmationLevel = "Normal"
    }
}

$defaultSettings | ConvertTo-Json | Out-File $userSettingsFile -Encoding UTF8
Write-Host "用户设置已重置"

Write-Host ""
Write-Host "配置文件修复完成！" -ForegroundColor Green
Write-Host "建议重启中望CAD以应用修复" -ForegroundColor Cyan
```

### 问题：数据丢失

**症状：**
- 查寻表数据缺失
- 参数配置丢失
- 用户设置重置

**数据恢复脚本：**
```powershell
# DataRecovery.ps1
Write-Host "开始数据恢复..." -ForegroundColor Yellow

$configDir = "$env:USERPROFILE\Documents\ZWDynLookup"
$backupDir = "$configDir\Backups"

# 1. 查找可用备份
Write-Host "1. 查找可用备份..." -ForegroundColor Yellow
$backups = @()
if (Test-Path $backupDir) {
    $backupFolders = Get-ChildItem $backupDir -Directory | Sort-Object LastWriteTime -Descending
    foreach ($folder in $backupFolders) {
        $backupInfo = @{
            Path = $folder.FullName
            Date = $folder.LastWriteTime
            Size = (Get-ChildItem $folder -Recurse -File | Measure-Object -Property Length -Sum).Sum
        }
        $backups += $backupInfo
    }
}

if ($backups.Count -eq 0) {
    Write-Host "未找到任何备份文件" -ForegroundColor Red
    Write-Host "请手动重建数据或联系技术支持" -ForegroundColor Yellow
    exit 1
}

Write-Host "找到 $($backups.Count) 个备份文件:"
$backups | ForEach-Object {
    $sizeMB = [math]::Round($_.Size / 1MB, 2)
    Write-Host "  $($_.Date) - $sizeMB MB - $($_.Path)"
}

# 2. 选择恢复源
Write-Host ""
Write-Host "2. 选择恢复源" -ForegroundColor Yellow
Write-Host "可用备份选项："
for ($i = 0; $i -lt $backups.Count; $i++) {
    Write-Host "  $($i + 1). $($backups[$i].Date) - $($backups[$i].Path)"
}

$selectedIndex = Read-Host "请选择要恢复的备份 (1-$($backups.Count))"
$selectedIndex = [int]$selectedIndex - 1

if ($selectedIndex -lt 0 -or $selectedIndex -ge $backups.Count) {
    Write-Host "无效的选择" -ForegroundColor Red
    exit 1
}

$selectedBackup = $backups[$selectedIndex]
Write-Host "选择恢复源: $($selectedBackup.Path)"

# 3. 创建当前数据备份
Write-Host ""
Write-Host "3. 创建当前数据备份..." -ForegroundColor Yellow
$currentBackupDir = "$configDir\CurrentBackup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
if (Test-Path $configDir) {
    Copy-Item $configDir $currentBackupDir -Recurse
    Write-Host "当前数据已备份到: $currentBackupDir"
}

# 4. 恢复数据
Write-Host ""
Write-Host "4. 恢复数据..." -ForegroundColor Yellow
try {
    # 清理当前数据
    Remove-Item $configDir -Recurse -Force
    New-Item -ItemType Directory -Path $configDir -Force
    
    # 恢复备份数据
    Copy-Item $selectedBackup.Path $configDir -Recurse
    Write-Host "数据恢复完成"
    
    # 恢复特定文件类型
    $restoreFiles = @("config.xml", "user_settings.json", "Plugin.log")
    foreach ($file in $restoreFiles) {
        $sourceFile = Join-Path $selectedBackup.Path $file
        if (Test-Path $sourceFile) {
            Copy-Item $sourceFile $configDir -Force
            Write-Host "已恢复: $file"
        }
    }
    
    Write-Host "数据恢复成功完成" -ForegroundColor Green
    
} catch {
    Write-Host "数据恢复失败: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "尝试回滚到当前备份..." -ForegroundColor Yellow
    
    # 回滚
    if (Test-Path $currentBackupDir) {
        Remove-Item $configDir -Recurse -Force
        Copy-Item $currentBackupDir $configDir -Recurse
        Write-Host "已回滚到修复前的状态"
    }
}

Write-Host ""
Write-Host "数据恢复完成！" -ForegroundColor Green
Write-Host "建议重启中望CAD并检查数据完整性" -ForegroundColor Cyan
```

---

## 高级故障排除

### 问题：插件冲突

**症状：**
- 同时安装的插件产生冲突
- 某些功能无法正常工作
- 出现未预期的错误

**插件冲突检测脚本：**
```powershell
# PluginConflictDetection.ps1
Write-Host "=== 插件冲突检测 ===" -ForegroundColor Green

# 1. 检测已安装的插件
Write-Host "1. 检测已安装的插件" -ForegroundColor Yellow
$pluginDirs = @(
    "$env:APPDATA\Autodesk\ApplicationPlugins",
    "$env:ALLUSERSPROFILE\Autodesk\ApplicationPlugins",
    "$env:PROGRAMFILES\Autodesk\ApplicationPlugins"
)

$installedPlugins = @()
foreach ($dir in $pluginDirs) {
    if (Test-Path $dir) {
        $plugins = Get-ChildItem $dir -Directory
        foreach ($plugin in $plugins) {
            $manifestFile = Join-Path $plugin.FullName "PackageContents.xml"
            if (Test-Path $manifestFile) {
                try {
                    [xml]$manifest = Get-Content $manifestFile
                    $pluginInfo = @{
                        Name = $plugin.Name
                        Path = $plugin.FullName
                        Version = $manifest.SelectSingleNode("//Application/@Version")?.Value
                        Description = $manifest.SelectSingleNode("//Application/@Description")?.Value
                        Dependencies = $manifest.SelectNodes("//Dependencies/Application").Count
                    }
                    $installedPlugins += $pluginInfo
                } catch {
                    Write-Host "无法读取插件清单: $($plugin.Name)" -ForegroundColor Red
                }
            }
        }
    }
}

Write-Host "发现 $($installedPlugins.Count) 个插件:"
foreach ($plugin in $installedPlugins) {
    Write-Host "  $($plugin.Name) v$($plugin.Version) - $($plugin.Description)"
    if ($plugin.Dependencies -gt 0) {
        Write-Host "    依赖数量: $($plugin.Dependencies)"
    }
}

# 2. 检查ZWDynLookup依赖
Write-Host ""
Write-Host "2. 检查ZWDynLookup依赖" -ForegroundColor Yellow
$zwcadLookup = $installedPlugins | Where-Object { $_.Name -like "*ZWDynLookup*" }
if ($zwcadLookup) {
    Write-Host "ZWDynLookup插件信息:"
    $zwcadLookup | ForEach-Object {
        Write-Host "  名称: $($_.Name)"
        Write-Host "  版本: $($_.Version)"
        Write-Host "  路径: $($_.Path)"
        Write-Host "  依赖: $($_.Dependencies)"
    }
} else {
    Write-Host "未找到ZWDynLookup插件" -ForegroundColor Red
}

# 3. 检查潜在冲突
Write-Host ""
Write-Host "3. 检查潜在冲突" -ForegroundColor Yellow
$potentialConflicts = @()

# 检查同名命令
$commandConflicts = @()
$allCommands = @()

foreach ($plugin in $installedPlugins) {
    $commandsFile = Join-Path $plugin.Path "Commands.txt"
    if (Test-Path $commandsFile) {
        $commands = Get-Content $commandsFile
        foreach ($cmd in $commands) {
            if ($cmd -in $allCommands) {
                $commandConflicts += $cmd
            }
            $allCommands += $cmd
        }
    }
}

if ($commandConflicts) {
    Write-Host "发现命令冲突:" -ForegroundColor Red
    $commandConflicts | Sort-Object | Get-Unique | ForEach-Object {
        Write-Host "  命令冲突: $_" -ForegroundColor Red
    }
    $potentialConflicts += "CommandConflict"
} else {
    Write-Host "未发现命令冲突" -ForegroundColor Green
}

# 检查文件冲突
$fileConflicts = @()
foreach ($plugin in $installedPlugins) {
    $pluginDlls = Get-ChildItem $plugin.Path -Filter "*.dll" | Select-Object Name, FullName
    foreach ($dll in $pluginDlls) {
        $conflictingPlugin = $installedPlugins | Where-Object { 
            $_.Path -ne $plugin.Path -and 
            (Test-Path (Join-Path $_.Path $dll.Name))
        }
        if ($conflictingPlugin) {
            $fileConflicts += @{
                File = $dll.Name
                Plugins = @($plugin.Name, $conflictingPlugin.Name)
            }
        }
    }
}

if ($fileConflicts) {
    Write-Host "发现文件冲突:" -ForegroundColor Red
    foreach ($conflict in $fileConflicts) {
        Write-Host "  文件冲突: $($conflict.File) (插件: $($conflict.Plugins -join ', '))" -ForegroundColor Red
    }
    $potentialConflicts += "FileConflict"
} else {
    Write-Host "未发现文件冲突" -ForegroundColor Green
}

# 4. 生成冲突解决建议
Write-Host ""
Write-Host "4. 冲突解决建议" -ForegroundColor Cyan
if ($potentialConflicts.Count -eq 0) {
    Write-Host "未发现严重冲突，建议正常运行" -ForegroundColor Green
} else {
    Write-Host "发现以下冲突类型:" -ForegroundColor Red
    foreach ($conflict in $potentialConflicts) {
        switch ($conflict) {
            "CommandConflict" {
                Write-Host "- 命令冲突解决:"
                Write-Host "  1. 检查插件注册的命令"
                Write-Host "  2. 重命名冲突的命令"
                Write-Host "  3. 禁用冲突的插件"
            }
            "FileConflict" {
                Write-Host "- 文件冲突解决:"
                Write-Host "  1. 检查插件依赖"
                Write-Host "  2. 更新插件到兼容版本"
                Write-Host "  3. 重新安装冲突的插件"
            }
        }
        Write-Host ""
    }
}

# 5. 插件健康检查
Write-Host "5. 插件健康检查" -ForegroundColor Yellow
foreach ($plugin in $installedPlugins) {
    $healthScore = 0
    $issues = @()
    
    # 检查文件完整性
    $requiredFiles = @("PackageContents.xml", "ZWDynLookup.dll")
    foreach ($file in $requiredFiles) {
        if (Test-Path (Join-Path $plugin.Path $file)) {
            $healthScore += 25
        } else {
            $issues += "缺失文件: $file"
        }
    }
    
    # 检查版本兼容性
    if ($plugin.Version) {
        $healthScore += 25
    } else {
        $issues += "版本信息缺失"
    }
    
    # 检查依赖
    if ($plugin.Dependencies -eq 0) {
        $healthScore += 25
    } else {
        $healthScore += 10
    }
    
    # 检查最近更新时间
    $lastModified = (Get-Item $plugin.Path).LastWriteTime
    if ((Get-Date) - $lastModified -lt [TimeSpan]::FromDays(30)) {
        $healthScore += 25
    }
    
    $healthStatus = switch ($healthScore) {
        { $_ -ge 90 } { "健康"; "Green" }
        { $_ -ge 70 } { "良好"; "Yellow" }
        { $_ -ge 50 } { "一般"; "Orange" }
        default { "需要关注"; "Red" }
    }
    
    $color = switch ($healthStatus) {
        "健康" { "Green" }
        "良好" { "Yellow" }
        "一般" { "Orange" }
        "需要关注" { "Red" }
    }
    
    Write-Host "$($plugin.Name): $healthStatus ($healthScore/100)" -ForegroundColor $color
    if ($issues.Count -gt 0) {
        $issues | ForEach-Object { Write-Host "  - $_" -ForegroundColor Yellow }
    }
}

Write-Host ""
Write-Host "=== 插件冲突检测完成 ===" -ForegroundColor Green
```

### 问题：系统资源耗尽

**症状：**
- 系统响应缓慢
- 内存占用过高
- 磁盘空间不足

**资源监控和清理脚本：**
```powershell
# ResourceManagement.ps1
param(
    [switch]$Cleanup = $false,
    [switch]$Monitor = $true
)

Write-Host "=== 系统资源管理 ===" -ForegroundColor Green

# 1. 系统资源监控
if ($Monitor) {
    Write-Host "1. 系统资源监控" -ForegroundColor Yellow
    
    # CPU使用率
    $cpu = Get-WmiObject -Class Win32_Processor
    Write-Host "CPU: $($cpu.LoadPercentage)% 使用率"
    
    # 内存使用情况
    $memory = Get-WmiObject -Class Win32_OperatingSystem
    $totalMemoryGB = [math]::Round($memory.TotalVisibleMemorySize / 1MB, 2)
    $freeMemoryGB = [math]::Round($memory.FreePhysicalMemory / 1MB, 2)
    $usedMemoryGB = $totalMemoryGB - $freeMemoryGB
    $memoryUsagePercent = [math]::Round(($usedMemoryGB / $totalMemoryGB) * 100, 1)
    
    Write-Host "内存: $usedMemoryGB GB / $totalMemoryGB GB ($memoryUsagePercent% 使用)"
    
    # 磁盘空间
    $disks = Get-WmiObject -Class Win32_LogicalDisk | Where-Object { $_.DriveType -eq 3 }
    foreach ($disk in $disks) {
        $usedSpaceGB = [math]::Round(($disk.Size - $disk.FreeSpace) / 1GB, 2)
        $totalSpaceGB = [math]::Round($disk.Size / 1GB, 2)
        $usagePercent = [math]::Round(($usedSpaceGB / $totalSpaceGB) * 100, 1)
        
        $statusColor = if ($usagePercent -gt 90) { "Red" } elseif ($usagePercent -gt 80) { "Yellow" } else { "Green" }
        Write-Host "磁盘 $($disk.DeviceID): $usedSpaceGB GB / $totalSpaceGB GB ($usagePercent% 使用)" -ForegroundColor $statusColor
    }
}

# 2. 插件资源监控
Write-Host ""
Write-Host "2. 插件资源监控" -ForegroundColor Yellow
$cadProcess = Get-Process ZwCAD -ErrorAction SilentlyContinue
if ($cadProcess) {
    $memoryMB = [math]::Round($cadProcess.WorkingSet64 / 1MB, 2)
    $threadCount = $cadProcess.Threads.Count
    $handleCount = $cadProcess.Handles.Count
    
    Write-Host "CAD进程内存: $memoryMB MB"
    Write-Host "CAD进程线程: $threadCount"
    Write-Host "CAD进程句柄: $handleCount"
    
    # 检查资源泄漏
    if ($memoryMB -gt 1000) {
        Write-Host "警告: CAD进程内存使用过高" -ForegroundColor Yellow
    }
    if ($handleCount -gt 10000) {
        Write-Host "警告: CAD进程句柄数量过高" -ForegroundColor Yellow
    }
} else {
    Write-Host "CAD进程未找到" -ForegroundColor Red
}

# 3. 文件句柄分析
Write-Host ""
Write-Host "3. 文件句柄分析" -ForegroundColor Yellow
$handleExe = "$env:ProgramFiles\Sysinternals\handle.exe"
if (Test-Path $handleExe) {
    $zwcadHandles = & $handleExe -a -p ZwCAD | Where-Object { $_ -match "\.dll|\.log|\.tmp" }
    $handleTypes = $zwcadHandles | ForEach-Object {
        if ($_ -match "\.dll") { "DLL文件" }
        elseif ($_ -match "\.log") { "日志文件" }
        elseif ($_ -match "\.tmp") { "临时文件" }
        else { "其他文件" }
    } | Group-Object | Select-Object Name, Count
    
    Write-Host "文件句柄分布:"
    foreach ($type in $handleTypes) {
        Write-Host "  $($type.Name): $($type.Count) 个"
    }
} else {
    Write-Host "Handle.exe 未安装，无法分析文件句柄" -ForegroundColor Yellow
}

# 4. 清理操作
if ($Cleanup) {
    Write-Host ""
    Write-Host "4. 执行清理操作" -ForegroundColor Yellow
    
    # 清理临时文件
    $tempLocations = @(
        "$env:TEMP",
        "$env:LOCALAPPDATA\Temp",
        "$env:USERPROFILE\AppData\Local\Temp"
    )
    
    $cleanedFiles = 0
    $cleanedSize = 0
    
    foreach ($tempDir in $tempLocations) {
        if (Test-Path $tempDir) {
            $oldFiles = Get-ChildItem $tempDir -File | Where-Object { 
                $_.LastWriteTime -lt (Get-Date).AddDays(-7) -and 
                $_.Extension -in @(".tmp", ".log", ".bak")
            }
            
            foreach ($file in $oldFiles) {
                try {
                    $cleanedSize += $file.Length
                    Remove-Item $file.FullName -Force
                    $cleanedFiles++
                } catch {
                    Write-Host "无法删除: $($file.FullName)" -ForegroundColor Red
                }
            }
        }
    }
    
    Write-Host "清理临时文件: $cleanedFiles 个文件, $([math]::Round($cleanedSize / 1MB, 2)) MB"
    
    # 清理插件缓存
    $pluginCacheDirs = @(
        "$env:LOCALAPPDATA\ZWDynLookup\Cache",
        "$env:USERPROFILE\Documents\ZWDynLookup\Temp"
    )
    
    foreach ($cacheDir in $pluginCacheDirs) {
        if (Test-Path $cacheDir) {
            $cacheSize = (Get-ChildItem $cacheDir -Recurse -File | Measure-Object -Property Length -Sum).Sum
            Remove-Item $cacheDir -Recurse -Force
            Write-Host "清理缓存: $([math]::Round($cacheSize / 1MB, 2)) MB"
        }
    }
    
    # 清理日志文件
    $logDir = "$env:USERPROFILE\Documents\ZWDynLookup"
    if (Test-Path $logDir) {
        $oldLogs = Get-ChildItem $logDir -Filter "*.log" | Where-Object { 
            $_.LastWriteTime -lt (Get-Date).AddDays(-30) 
        }
        
        $logSize = 0
        foreach ($log in $oldLogs) {
            $logSize += $log.Length
            Remove-Item $log.FullName -Force
        }
        
        if ($logSize -gt 0) {
            Write-Host "清理旧日志: $([math]::Round($logSize / 1MB, 2)) MB"
        }
    }
    
    # 强制垃圾回收
    [System.GC]::Collect()
    [System.GC]::WaitForPendingFinalizers()
    [System.GC]::Collect()
    
    Write-Host "清理操作完成" -ForegroundColor Green
}

# 5. 生成资源报告
Write-Host ""
Write-Host "5. 资源管理报告" -ForegroundColor Yellow
$report = @{
    Timestamp = Get-Date
    SystemResources = @{
        CPU = $cpu.LoadPercentage
        Memory = @{
            TotalGB = $totalMemoryGB
            UsedGB = $usedMemoryGB
            UsagePercent = $memoryUsagePercent
        }
    }
    PluginResources = if ($cadProcess) @{
        MemoryMB = $memoryMB
        ThreadCount = $threadCount
        HandleCount = $handleCount
    } else $null
    CleanupPerformed = $Cleanup
}

$reportFile = "$env:TEMP\ZWDynLookup_ResourceReport_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
$report | ConvertTo-Json | Out-File $reportFile

Write-Host "资源报告已保存: $reportFile"
Write-Host ""
Write-Host "=== 系统资源管理完成 ===" -ForegroundColor Green

# 6. 优化建议
Write-Host ""
Write-Host "6. 优化建议" -ForegroundColor Cyan
if ($memoryUsagePercent -gt 80) {
    Write-Host "- 内存使用率较高，建议:"
    Write-Host "  * 重启中望CAD"
    Write-Host "  * 关闭不必要的程序"
    Write-Host "  * 增加物理内存"
}

if ($usagePercent -gt 90) {
    Write-Host "- 磁盘空间不足，建议:"
    Write-Host "  * 清理临时文件"
    Write-Host "  * 清理旧日志文件"
    Write-Host "  * 清理不必要的程序"
}

if ($cadProcess -and ($memoryMB -gt 1000)) {
    Write-Host "- CAD进程内存使用过高，建议:"
    Write-Host "  * 重启中望CAD"
    Write-Host "  * 减少同时打开的文件"
    Write-Host "  * 检查插件冲突"
}

Write-Host "- 定期维护建议:"
Write-Host "  * 每周运行清理脚本"
Write-Host "  * 监控资源使用情况"
Write-Host "  * 及时更新插件版本"
```

---

## 联系技术支持

### 问题报告模板
当遇到无法解决的问题时，请使用以下模板报告问题：

```markdown
### 问题报告

**基本信息：**
- 插件版本：1.0.0
- 中望CAD版本：2024
- 操作系统：Windows 11
- 用户类型：[个人/企业/教育]

**问题描述：**
[详细描述问题的症状]

**重现步骤：**
1. [步骤1]
2. [步骤2]
3. [步骤3]

**期望结果：**
[描述期望的正确行为]

**实际结果：**
[描述实际发生的错误]

**错误信息：**
```
[粘贴完整的错误信息]
```

**系统环境：**
- CPU：[处理器型号]
- 内存：[内存大小]
- 显卡：[显卡型号]
- .NET Framework版本：[版本号]

**相关文件：**
- 插件日志文件：`%USERPROFILE%\Documents\ZWDynLookup\Plugin.log`
- 配置文件：`%USERPROFILE%\Documents\ZWDynLookup\config.xml`
- 系统信息：运行 `systeminfo > systeminfo.txt`

**附加信息：**
- 是否在虚拟机中运行：[是/否]
- 是否同时安装其他插件：[列表插件名称]
- 最近的系统更改：[描述系统变化]

**联系方式：**
- 邮箱：[your-email@domain.com]
- 电话：[联系电话]
- 最佳联系时间：[时间段]
```

### 支持渠道

**在线支持：**
- 官方网站：https://www.zwdynlookup.com/support
- 在线文档：https://docs.zwdynlookup.com
- 视频教程：https://tutorials.zwdynlookup.com
- 社区论坛：https://forum.zwdynlookup.com

**直接联系：**
- 技术支持邮箱：support@zwdynlookup.com
- 销售咨询邮箱：sales@zwdynlookup.com
- 在线客服：工作日 9:00-18:00
- 技术热线：400-XXX-XXXX

**远程支持：**
- 支持TeamViewer远程协助
- 需要预先预约
- 提供屏幕共享支持

---

**文档版本：** 1.0  
**最后更新：** 2024年12月  
**维护者：** 中望CAD动态块查寻插件开发团队