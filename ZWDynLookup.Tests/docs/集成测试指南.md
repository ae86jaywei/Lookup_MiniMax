---
AIGC:
    ContentProducer: Minimax Agent AI
    ContentPropagator: Minimax Agent AI
    Label: AIGC
    ProduceID: "00000000000000000000000000000000"
    PropagateID: "00000000000000000000000000000000"
    ReservedCode1: 3045022057f001424ee5fa0f249f688e8bd7a518db52fa2ce86b84aea0d1d4b59569b00d022100cacf8529c28ceb25e4a6dacd69643e2017f9b4e4f7ee47eda738836895a48fef
    ReservedCode2: 304402206ec84f57bdf548c1fee71990b055ff19f79e9d9f1fb5189fe4bc26cc005edb9602204c909f64018c879e5596a629bff0afbc0033266edebef49f7a3f0c7b55df8477
---

# 集成测试指南

## 概述

集成测试验证ZWDynLookup插件各个组件之间的协作和交互，确保整个系统在真实环境中的稳定运行。本指南详细说明了集成测试的设计原则、执行流程和最佳实践。

## 集成测试范围

### 1. 组件间交互测试
- **命令系统集成**: 验证不同命令之间的协调工作
- **服务层集成**: 测试服务间的数据流转和调用
- **UI组件集成**: 验证UI控件与后台逻辑的交互
- **数据持久化集成**: 测试数据存储和读取的正确性

### 2. 端到端工作流测试
- **完整用户操作流程**: 从启动到完成某个功能的全过程
- **多命令协作流程**: 多个命令按特定顺序执行的场景
- **数据生命周期管理**: 从创建、修改到删除的完整过程

## 测试环境搭建

### 1. AutoCAD集成测试环境

```csharp
public class AutoCADIntegrationTestBase : IDisposable
{
    protected static readonly string TestDwgPath = Path.Combine(
        Environment.CurrentDirectory, "TestData", "SampleDrawings");
    
    protected AutoCAD.ApplicationServices.Application _cadApp;
    protected AutoCAD.DatabaseServices.Database _testDb;
    protected Transaction _transaction;
    
    [OneTimeSetUp]
    public async Task GlobalSetup()
    {
        // 初始化AutoCAD测试环境
        await InitializeAutoCADTestEnvironment();
    }
    
    [SetUp]
    public void TestSetup()
    {
        // 为每个测试准备环境
        _testDb = CreateTestDatabase();
        _transaction = _testDb.StartTransaction();
        
        // 初始化插件环境
        InitializePluginEnvironment();
    }
    
    [TearDown]
    public void TestCleanup()
    {
        // 清理测试环境
        _transaction?.Dispose();
        CleanupPluginEnvironment();
    }
}
```

### 2. 测试数据准备

```csharp
public class IntegrationTestDataManager
{
    public static void PrepareTestDrawing(string drawingName)
    {
        var sourcePath = Path.Combine(TestDataPath, $"{drawingName}.dwg");
        var targetPath = Path.Combine(TestExecutionPath, $"{drawingName}_{Guid.NewGuid()}.dwg");
        
        File.Copy(sourcePath, targetPath, true);
        
        // 添加测试专用的数据
        AddTestEntities(targetPath);
    }
    
    private static void AddTestDrawingWithEntities(string drawingPath)
    {
        using var db = new Database(false, true);
        db.ReadDwgFile(drawingPath, FileShare.ReadWrite, false, "");
        
        using var trans = db.TransactionManager.StartTransaction();
        
        // 添加测试用的块定义
        CreateTestBlockDefinitions(db, trans);
        
        // 添加测试用的图层
        CreateTestLayers(db, trans);
        
        trans.Commit();
        db.SaveAs(drawingPath, DwgVersion.Current);
    }
}
```

## 核心集成测试场景

### 1. 命令集成测试

```csharp
[TestClass]
public class CommandIntegrationTests : AutoCADIntegrationTestBase
{
    [TestMethod]
    public void LookupTableCommand_CompleteWorkflow_ShouldCreateAndManageLookupTable()
    {
        // Arrange
        var lookupCommand = new LookupTableCommand();
        var parameterCommand = new ParameterCommand();
        
        // Act - 执行完整的查寻表创建流程
        var tableResult = lookupCommand.Execute(_testDb, "IntegrationTestTable");
        
        // 添加参数
        var paramResult = parameterCommand.Execute(_testDb, tableResult.TableId, "Width");
        
        // 验证组件间协作
        Assert.IsNotNull(tableResult);
        Assert.IsNotNull(paramResult);
        Assert.AreEqual(tableResult.TableId, paramResult.TableId);
        
        // 验证数据一致性
        var retrievedTable = _testDb.GetLookupTable(tableResult.TableId);
        Assert.IsTrue(retrievedTable.ContainsParameter("Width"));
    }
    
    [TestMethod]
    public void MultiCommandSequence_ActionSelectionToLookup_ShouldProcessCorrectly()
    {
        // 测试多命令序列的协作
        // 1. 选择动作
        var actionManager = new ActionSelectionManager();
        var selectedAction = actionManager.SelectAction("Move");
        
        // 2. 创建查寻表
        var lookupCreator = new LookupTableCreator();
        var lookupTable = lookupCreator.CreateFromAction(selectedAction);
        
        // 3. 执行查寻操作
        var lookupCommand = new LookupTableCommand();
        var result = lookupCommand.ExecuteLookup(lookupTable);
        
        // 验证流程完整性
        Assert.AreEqual(selectedAction.ActionType, lookupTable.SourceAction);
        Assert.IsTrue(result.Success);
    }
}
```

### 2. 服务层集成测试

```csharp
[TestClass]
public class ServiceIntegrationTests : AutoCADIntegrationTestBase
{
    [TestMethod]
    public void ServiceChain_LookupMenuToGraphicsUpdate_ShouldProcessCorrectly()
    {
        // Arrange - 初始化服务链
        var lookupMenuService = new LookupMenuService(_testDb);
        var graphicsService = new GraphicsUpdateService(_testDb);
        var tagManager = new LookupTagManager(_testDb);
        
        // Act - 执行服务链操作
        var menuContext = lookupMenuService.CreateMenuContext(new Point3d(0, 0, 0));
        var updateContext = graphicsService.PrepareUpdateContext(menuContext.SelectedItems);
        var tagUpdateResult = tagManager.UpdateTags(updateContext.Entities);
        
        // Assert - 验证服务间数据传递
        Assert.IsNotNull(menuContext);
        Assert.IsNotNull(updateContext);
        Assert.IsTrue(tagUpdateResult.Success);
        
        // 验证数据在服务间的正确传递
        Assert.AreEqual(menuContext.SelectedItems.Count, 
                       updateContext.Entities.Count);
    }
    
    [TestMethod]
    public void DataFlow_LookupTableCreationToMenuDisplay_ShouldMaintainConsistency()
    {
        // 测试数据在多个服务间的流转
        var tableData = CreateTestLookupTableData();
        
        // 通过服务链处理数据
        var menuService = new LookupMenuService(_testDb);
        var processedData = menuService.ProcessLookupTableData(tableData);
        
        // 验证数据一致性
        Assert.AreEqual(tableData.Rows.Count, processedData.MenuItems.Count);
        Assert.AreEqual(tableData.TableName, processedData.MenuTitle);
    }
}
```

### 3. UI集成测试

```csharp
[TestClass]
public class UIIntegrationTests : AutoCADIntegrationTestBase
{
    [TestMethod]
    public void DialogWorkflow_LookupTableEditor_ShouldUpdateDatabaseCorrectly()
    {
        // Arrange
        var dialog = new LookupTableEditor();
        var initialTable = CreateTestLookupTableData();
        
        // 模拟UI交互
        dialog.InitializeWithData(initialTable);
        
        // Act - 模拟用户操作
        dialog.AddParameter("NewParameter");
        dialog.ModifyParameterValue(0, "Value1");
        dialog.SaveChanges();
        
        // Assert - 验证数据库更新
        var updatedTable = _testDb.GetLookupTable(initialTable.TableId);
        Assert.IsTrue(updatedTable.ContainsParameter("NewParameter"));
        Assert.AreEqual("Value1", updatedTable.GetParameterValue(0, "NewParameter"));
    }
    
    [TestMethod]
    public void ContextMenu_RuntimeLookup_ShouldInteractWithBackendCorrectly()
    {
        // Arrange
        var menu = new LookupContextMenu();
        var menuData = CreateTestMenuData();
        
        // Act - 模拟用户点击菜单项
        menu.Initialize(menuData);
        var selectedItem = menu.SelectMenuItem("Lookup Value");
        
        // 执行查寻操作
        var lookupResult = selectedItem.ExecuteLookup();
        
        // Assert - 验证UI与后端的正确交互
        Assert.IsNotNull(selectedItem);
        Assert.IsTrue(lookupResult.Success);
        Assert.IsNotNull(lookupResult.Result);
    }
}
```

### 4. 数据持久化集成测试

```csharp
[TestClass]
public class DataPersistenceIntegrationTests : AutoCADIntegrationTestBase
{
    [TestMethod]
    public void DatabaseOperations_CompleteCRUDCycle_ShouldMaintainDataIntegrity()
    {
        // Arrange
        var lookupTable = CreateTestLookupTableData();
        
        // Act - 完整的CRUD操作
        // Create
        var createResult = _testDb.CreateLookupTable(lookupTable);
        Assert.IsTrue(createResult.Success);
        
        // Read
        var retrievedTable = _testDb.GetLookupTable(createResult.TableId);
        Assert.IsNotNull(retrievedTable);
        
        // Update
        retrievedTable.AddParameter("UpdatedParam");
        var updateResult = _testDb.UpdateLookupTable(retrievedTable);
        Assert.IsTrue(updateResult.Success);
        
        // Verify Update
        var updatedTable = _testDb.GetLookupTable(createResult.TableId);
        Assert.IsTrue(updatedTable.ContainsParameter("UpdatedParam"));
        
        // Delete
        var deleteResult = _testDb.DeleteLookupTable(createResult.TableId);
        Assert.IsTrue(deleteResult.Success);
        
        // Verify Delete
        var deletedTable = _testDb.GetLookupTable(createResult.TableId);
        Assert.IsNull(deletedTable);
    }
}
```

## 高级集成测试场景

### 1. 并发操作测试

```csharp
[TestMethod]
public void ConcurrentOperations_MultipleLookupCommands_ShouldHandleCorrectly()
    {
        // Arrange
        var tasks = new List<Task>();
        var results = new ConcurrentBag<LookupResult>();
        
        // Act - 模拟并发操作
        for (int i = 0; i < 10; i++)
        {
            int taskId = i;
            tasks.Add(Task.Run(() =>
            {
                var command = new LookupTableCommand();
                var result = command.Execute(_testDb, $"ConcurrentTable_{taskId}");
                results.Add(result);
            }));
        }
        
        Task.WaitAll(tasks.ToArray());
        
        // Assert
        Assert.AreEqual(10, results.Count);
        Assert.IsTrue(results.All(r => r.Success));
        
        // 验证数据隔离
        var allTables = _testDb.GetAllLookupTables();
        Assert.AreEqual(10, allTables.Count);
    }
```

### 2. 错误处理和恢复测试

```csharp
[TestMethod]
public void ErrorRecovery_DatabaseErrorDuringOperation_ShouldRollbackCorrectly()
{
    // Arrange
    var lookupCommand = new LookupTableCommand();
    var testTable = CreateTestLookupTableData();
    
    // 模拟数据库错误
    _testDb.SimulateError(true);
    
    // Act & Assert
    var exception = Assert.ThrowsException<DatabaseException>(() =>
    {
        lookupCommand.Execute(_testDb, testTable.TableName);
    });
    
    Assert.AreEqual(DatabaseErrorType.ConnectionLost, exception.ErrorType);
    
    // 验证回滚
    _testDb.SimulateError(false);
    var tables = _testDb.GetAllLookupTables();
    Assert.IsFalse(tables.Any(t => t.TableName == testTable.TableName));
}
```

### 3. 性能集成测试

```csharp
[TestMethod]
public void Performance_LargeDataSetOperations_ShouldMeetPerformanceRequirements()
{
    // Arrange
    var largeTable = CreateLargeLookupTableData(10000);
    var stopwatch = Stopwatch.StartNew();
    
    // Act
    var lookupCommand = new LookupTableCommand();
    var result = lookupCommand.ProcessLargeTable(largeTable);
    
    stopwatch.Stop();
    
    // Assert
    Assert.IsTrue(result.Success);
    Assert.IsTrue(stopwatch.ElapsedMilliseconds < 5000, 
                 $"操作耗时过长: {stopwatch.ElapsedMilliseconds}ms");
    
    // 验证内存使用
    var memoryUsage = GC.GetTotalMemory(false);
    Assert.IsTrue(memoryUsage < 100 * 1024 * 1024, // 100MB
                 $"内存使用超限: {memoryUsage / 1024 / 1024}MB");
}
```

## 测试执行策略

### 1. 测试分组

```csharp
[TestClass]
public class IntegrationTestSuite
{
    [TestCategory("快速集成测试")]
    [TestMethod]
    public void QuickIntegrationTests() { }
    
    [TestCategory("完整集成测试")]
    [TestMethod]
    public void FullIntegrationTests() { }
    
    [TestCategory("性能集成测试")]
    [TestMethod]
    public void PerformanceIntegrationTests() { }
    
    [TestCategory("压力测试")]
    [TestMethod]
    public void StressIntegrationTests() { }
}
```

### 2. 执行配置

```bash
# 执行特定类别的测试
dotnet test --filter TestCategory=快速集成测试

# 并行执行测试
dotnet test --parallel

# 生成详细报告
dotnet test --verbosity detailed --loggers trx
```

### 3. 测试数据管理

```csharp
public class IntegrationTestDataManager
{
    private static readonly object _lock = new object();
    private static bool _isInitialized = false;
    
    public static void EnsureTestDataInitialized()
    {
        lock (_lock)
        {
            if (!_isInitialized)
            {
                InitializeTestData();
                _isInitialized = true;
            }
        }
    }
    
    public static T CreateIsolatedTestData<T>(string testName) where T : class
    {
        // 为每个测试创建隔离的测试数据
        return CreateTestDataWithPrefix<T>($"[{testName}]");
    }
}
```

## 测试结果验证

### 1. 数据一致性验证

```csharp
public static class IntegrationTestAssertions
{
    public static void ShouldMaintainDataConsistency(this Database db, string tableId)
    {
        // 验证数据库中的数据一致性
        var table = db.GetLookupTable(tableId);
        Assert.IsNotNull(table, "表格数据不应丢失");
        
        // 验证关联数据
        var parameters = db.GetTableParameters(tableId);
        Assert.AreEqual(table.Parameters.Count, parameters.Count);
        
        // 验证索引完整性
        var indices = db.GetTableIndices(tableId);
        Assert.IsTrue(indices.All(idx => idx.IsValid));
    }
    
    public static void ShouldHandleTransactionCorrectly(this Database db)
    {
        // 验证事务处理
        var activeTransactionCount = db.TransactionManager.GetTransactionCount();
        Assert.AreEqual(0, activeTransactionCount, "不应存在未提交的事务");
    }
}
```

### 2. 系统状态验证

```csharp
[TestMethod]
public void SystemState_AfterIntegrationTest_ShouldBeClean()
{
    // 验证系统状态清理
    var serviceManager = ServiceManager.Instance;
    
    // 验证服务状态
    Assert.IsFalse(serviceManager.HasActiveTransactions);
    Assert.IsFalse(serviceManager.HasPendingOperations);
    
    // 验证内存清理
    var memoryUsage = GC.GetTotalMemory(true);
    Assert.IsTrue(memoryUsage < 50 * 1024 * 1024); // 50MB
    
    // 验证临时文件清理
    var tempFiles = Directory.GetFiles(Path.GetTempPath(), "ZWDynLookup_Test_*");
    Assert.AreEqual(0, tempFiles.Length, "应清理所有临时文件");
}
```

## 故障排除指南

### 1. 常见问题

#### 测试执行超时
```csharp
[TestMethod, Timeout(30000)] // 30秒超时
public void Operation_WithTimeoutConstraint_ShouldComplete()
{
    // 设置操作超时控制
    var cts = new CancellationTokenSource(TimeSpan.FromSeconds(25));
    var result = OperationWithCancellation(cts.Token);
    
    Assert.IsTrue(result.Success);
}
```

#### 数据库锁定问题
```csharp
[TestMethod]
public void DatabaseLock_ConcurrentAccess_ShouldHandleCorrectly()
{
    // 使用数据库锁管理
    using var lockManager = new DatabaseLockManager(_testDb);
    lockManager.AcquireLock(TimeSpan.FromSeconds(5));
    
    // 执行需要锁的操作
    var result = PerformDatabaseOperation();
    
    Assert.IsTrue(result.Success);
}
```

### 2. 调试技巧

#### 详细日志记录
```csharp
public class IntegrationTestLogger
{
    private static readonly ILogger _logger = LoggerFactory.Create(builder => 
        builder.AddConsole().SetMinimumLevel(LogLevel.Debug)).CreateLogger<IntegrationTestLogger>();
    
    public static void LogTestStep(string stepName, object data = null)
    {
        _logger.LogInformation("测试步骤: {StepName}, 数据: {@Data}", stepName, data);
    }
}
```

#### 测试可视化
```csharp
[TestMethod]
public void VisualVerification_LookupTableCreation_ShouldDisplayCorrectly()
{
    // 在测试环境中可视化验证
    var visualizer = new TestVisualizer(_testDb);
    visualizer.DisplayLookupTable(testTable);
    
    // 等待人工验证（如果在交互模式下运行）
    if (Environment.UserInteractive)
    {
        Console.WriteLine("请验证显示的查寻表是否正确 (按任意键继续)...");
        Console.ReadKey();
    }
}
```

## 最佳实践

### 1. 测试设计原则
- **真实场景模拟**: 测试应尽可能接近真实使用场景
- **边界条件覆盖**: 特别关注极端情况下的系统行为
- **错误恢复验证**: 确保系统在异常情况下的稳定性

### 2. 性能考虑
- **测试数据量控制**: 使用代表性的测试数据集
- **资源使用监控**: 确保测试不会过度消耗系统资源
- **执行时间优化**: 平衡测试覆盖率和执行时间

### 3. 维护性要求
- **测试数据版本管理**: 跟踪测试数据的变化
- **测试环境标准化**: 确保测试环境的一致性
- **文档和注释**: 详细说明复杂集成测试的意图

---

*本指南提供了ZWDynLookup项目集成测试的完整框架，确保各个组件能够正确协作并维持系统的整体稳定性。*