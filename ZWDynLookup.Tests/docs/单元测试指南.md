---
AIGC:
    ContentProducer: Minimax Agent AI
    ContentPropagator: Minimax Agent AI
    Label: AIGC
    ProduceID: "00000000000000000000000000000000"
    PropagateID: "00000000000000000000000000000000"
    ReservedCode1: 30460221009cc8a990f8bbb6b93ab9a5466acd4f2d30cd5caf4e3454ba4308b3ff225e42cc022100d9d9885e688402887a30d6b7bfae60054bd91abd704890d28a601a278c0b0e29
    ReservedCode2: 30440220384e11ad34ca27a71ca2d954f74525ffc39fb8a640a9f01880a37eb37b98c2b502207d45d357b9d875cf48785dae19a2cc3ba7c31f2ade215ea9402284acdd071784
---

# 单元测试编写和使用指南

## 概述

单元测试是测试金字塔的基础层，负责验证代码的最小可测试单元（通常是方法或函数）的功能正确性。本指南详细说明了ZWDynLookup项目中单元测试的编写规范、执行流程和最佳实践。

## 测试框架选择

### 推荐框架: MSTest v3
- **优势**: 与Visual Studio深度集成，支持并行执行
- **项目配置**: 在`.csproj`文件中添加测试项目引用

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0-windows</TargetFramework>
    <UseWPF>true</UseWPF>
    <IsPackable>false</IsPackable>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="MSTest.TestAdapter" Version="3.0.4" />
    <PackageReference Include="MSTest.TestFramework" Version="3.0.4" />
    <PackageReference Include="coverlet.collector" Version="6.0.0" />
  </ItemGroup>
</Project>
```

## 测试项目结构

```
ZWDynLookup.Tests/
├── UnitTests/
│   ├── Commands/
│   │   ├── LookupTableCommandTests.cs
│   │   ├── ParameterCommandTests.cs
│   │   └── ActionSelectionManagerTests.cs
│   ├── Services/
│   │   ├── LookupMenuServiceTests.cs
│   │   ├── BlockReferenceHelperTests.cs
│   │   └── GraphicsUpdateServiceTests.cs
│   ├── Models/
│   │   ├── LookupTableDataTests.cs
│   │   └── ParameterPropertyTests.cs
│   └── UI/
│       ├── DialogTests/
│       └── ControlsTests/
├── TestHelpers/
│   ├── MockObjectFactory.cs
│   ├── TestDataProvider.cs
│   └── AssertionHelper.cs
└── TestData/
    ├── SampleDwgFiles/
    └── JsonTestData/
```

## 测试编写规范

### 1. AAA模式 (Arrange-Act-Assert)

每个测试方法应遵循AAA模式：

```csharp
[TestMethod]
public void LookupTableCommand_Execute_WithValidTable_ShouldCreateLookupTable()
{
    // Arrange - 准备测试数据
    var mockDatabase = CreateMockDatabase();
    var command = new LookupTableCommand();
    var expectedTableName = "TestTable";
    
    // Act - 执行被测试的操作
    var result = command.Execute(mockDatabase.Object, expectedTableName);
    
    // Assert - 验证结果
    Assert.IsNotNull(result);
    Assert.AreEqual(expectedTableName, result.TableName);
    Assert.IsTrue(result.IsValid);
}
```

### 2. 测试命名规范

测试方法命名应清晰表达测试意图：

```csharp
// 正确命名
[TestMethod]
public void ParameterProperty_Constructor_WithValidData_ShouldInitializeProperties()
[TestMethod]
public void LookupMenuService_FindMenuItem_WithNonExistentName_ShouldReturnNull()
[TestMethod]
public void BlockReferenceHelper_GetBlockNames_WithEmptyDatabase_ShouldReturnEmptyList()

// 避免使用模糊命名
[TestMethod]
public void Test1() // ❌ 不推荐
public void ShouldWork() // ❌ 不推荐
```

### 3. 测试数据准备

使用测试辅助类准备数据：

```csharp
[TestClass]
public class LookupTableCommandTests
{
    private MockObjectFactory _mockFactory;
    private TestDataProvider _dataProvider;
    
    [TestInitialize]
    public void Setup()
    {
        _mockFactory = new MockObjectFactory();
        _dataProvider = new TestDataProvider();
    }
    
    [TestMethod]
    public void ExecuteCommand_WithSampleData_ShouldProcessCorrectly()
    {
        // 使用工厂创建模拟对象
        var mockDatabase = _mockFactory.CreateMockDatabase();
        var sampleData = _dataProvider.GetSampleLookupTableData();
        
        // 测试逻辑...
    }
}
```

## 模拟(Mocking)策略

### 1. 使用Moq框架

```csharp
[TestMethod]
public void LookupMenuService_ShowContextMenu_WithValidPoint_ShouldDisplayMenu()
{
    // 创建模拟对象
    var mockDatabase = new Mock<Database>();
    var mockEditor = new Mock<Editor>();
    var mockGraphics = new Mock<GraphicsManager>();
    
    // 配置模拟行为
    mockEditor.Setup(e => e.GetPoint(It.IsAny<PromptPointOptions>()))
              .Returns(new PromptPointResult { Value = new Point3d(0, 0, 0) });
    
    // 执行测试
    var service = new LookupMenuService(mockDatabase.Object, mockEditor.Object, mockGraphics.Object);
    service.ShowContextMenu(new Point3d(0, 0, 0));
    
    // 验证交互
    mockEditor.Verify(e => e.GetPoint(It.IsAny<PromptPointOptions>()), Times.Once);
}
```

### 2. AutoCAD API模拟

创建AutoCAD API的模拟实现：

```csharp
public class MockDatabase : Database
{
    private readonly Dictionary<string, BlockTableRecord> _blocks;
    
    public MockDatabase()
    {
        _blocks = new Dictionary<string, BlockTableRecord>();
        InitializeMockData();
    }
    
    private void InitializeMockData()
    {
        // 添加测试用的模拟数据
        var blockTable = new BlockTable();
        _blocks["TestBlock"] = CreateTestBlockTableRecord();
    }
    
    public override BlockTable GetBlockTable(Transaction tr)
    {
        return new MockBlockTable(_blocks);
    }
}
```

## 断言(Assertion)最佳实践

### 1. 使用具体的断言方法

```csharp
// 推荐：使用具体的断言
Assert.AreEqual(expected, actual);
Assert.IsNotNull(result);
Assert.IsTrue(result.IsValid);
Assert.AreSame(expectedObject, actualObject);

// 避免：过于通用的断言
Assert.IsTrue(expected == actual); // ❌ 不推荐
```

### 2. 自定义断言辅助类

```csharp
public static class LookupTableAssertions
{
    public static void ShouldHaveValidStructure(this LookupTableData table)
    {
        Assert.IsNotNull(table, "表格数据不应为空");
        Assert.IsTrue(table.Rows.Count > 0, "表格应至少包含一行数据");
        Assert.IsFalse(string.IsNullOrEmpty(table.TableName), "表格名称不应为空");
    }
    
    public static void ShouldContainParameter(this LookupTableData table, string parameterName)
    {
        Assert.IsTrue(table.Parameters.Contains(parameterName), 
                     $"表格应包含参数: {parameterName}");
    }
}
```

使用自定义断言：
```csharp
[TestMethod]
public void LookupTableData_LoadFromJson_WithValidData_ShouldHaveValidStructure()
{
    var tableData = LookupTableData.LoadFromJson(TestDataProvider.GetValidJsonData());
    
    tableData.ShouldHaveValidStructure();
    tableData.ShouldContainParameter("Width");
}
```

## 参数化测试

### 1. 数据驱动测试

```csharp
[TestClass]
public class ParameterValidationTests
{
    [DataTestMethod]
    [DataRow("", false, "空字符串应无效")]
    [DataRow("ValidParam", true, "有效参数名应通过验证")]
    [DataRow("Invalid Param", false, "包含空格的参数名应无效")]
    [DataRow("123Param", false, "以数字开头的参数名应无效")]
    public void ValidateParameterName_WithVariousInputs_ShouldReturnExpectedResult(
        string input, bool expectedResult, string description)
    {
        // Arrange
        var validator = new ParameterValidator();
        
        // Act
        var actualResult = validator.IsValidParameterName(input);
        
        // Assert
        Assert.AreEqual(expectedResult, actualResult, description);
    }
}
```

### 2. 复杂参数化测试

```csharp
public static class TheoryDataProvider
{
    public static TheoryData<LookupTableData, int, bool> ValidTableData =>
        new()
        {
            { CreateEmptyTable(), 0, false },
            { CreateTableWithOneRow(), 1, true },
            { CreateTableWithMultipleRows(), 100, true }
        };
}

[Theory]
[ClassData(typeof(TheoryDataProvider))]
public void ProcessLookupTable_WithVariousTableSizes_ShouldHandleCorrectly(
    LookupTableData table, int rowCount, bool expectedResult)
{
    // 测试逻辑...
}
```

## 异常测试

### 1. 测试预期异常

```csharp
[TestMethod]
[ExpectedException(typeof(ArgumentException))]
public void LookupTableCommand_Execute_WithNullDatabase_ShouldThrowArgumentException()
{
    // Arrange
    var command = new LookupTableCommand();
    
    // Act - 这里会抛出异常
    command.Execute(null, "TestTable");
    
    // Assert - 由ExpectedException属性处理
}

[TestMethod]
public void ParameterValidator_Validate_WithNullInput_ShouldThrowArgumentNullException()
{
    // 使用Assert.ThrowsException进行更精确的异常测试
    var validator = new ParameterValidator();
    
    var exception = Assert.ThrowsException<ArgumentNullException>(() =>
    {
        validator.Validate(null);
    });
    
    Assert.AreEqual("parameter", exception.ParamName);
}
```

### 2. 自定义异常测试

```csharp
[TestMethod]
public void LookupMenuService_LoadMenu_WithCorruptedMenuData_ShouldThrowMenuLoadException()
{
    // Arrange
    var service = new LookupMenuService();
    var corruptedData = "{ invalid json data }";
    
    // Act & Assert
    var exception = Assert.ThrowsException<MenuLoadException>(() =>
    {
        service.LoadMenu(corruptedData);
    });
    
    Assert.IsTrue(exception.Message.Contains("菜单数据格式错误"));
    Assert.AreEqual(MenuLoadError.DataCorruption, exception.ErrorCode);
}
```

## 测试隔离和清理

### 1. 使用TestInitialize和TestCleanup

```csharp
[TestClass]
public class GraphicsUpdateServiceTests : IDisposable
{
    private GraphicsUpdateService _service;
    private Mock<Database> _mockDatabase;
    private Transaction _transaction;
    
    [TestInitialize]
    public void Setup()
    {
        _mockDatabase = new Mock<Database>();
        _service = new GraphicsUpdateService(_mockDatabase.Object);
        _transaction = _mockDatabase.Object.StartTransaction();
        
        // 准备测试环境
        SetupTestEnvironment();
    }
    
    [TestCleanup]
    public void Cleanup()
    {
        // 清理测试数据
        CleanupTestData();
        
        // 结束事务
        _transaction?.Dispose();
    }
    
    public void Dispose()
    {
        _service?.Dispose();
    }
}
```

### 2. 使用 IDisposable 进行资源管理

```csharp
public class TestDatabase : IDisposable
{
    private readonly string _testDbPath;
    private Database _database;
    
    public TestDatabase(string testDbPath)
    {
        _testDbPath = testDbPath;
        CreateTestDatabase();
    }
    
    public Database Database => _database;
    
    public void Dispose()
    {
        _database?.Dispose();
        if (File.Exists(_testDbPath))
        {
            File.Delete(_testDbPath);
        }
    }
}
```

## 测试执行和报告

### 1. 运行测试

#### 通过Visual Studio运行
```bash
# 在Visual Studio中
测试 → 运行 → 所有测试

# 或使用测试资源管理器
测试 → 窗口 → 测试资源管理器
```

#### 通过命令行运行
```bash
# 运行所有测试
dotnet test

# 运行特定项目
dotnet test ZWDynLookup.Tests.csproj

# 生成覆盖率报告
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura

# 生成详细报告
dotnet test --verbosity detailed
```

### 2. 测试结果分析

测试执行后，会生成以下报告：
- **测试资源管理器**: 实时测试状态
- **TestResults目录**: 详细测试结果
- **覆盖率报告**: 代码覆盖率统计

### 3. 覆盖率分析

```bash
# 生成HTML覆盖率报告
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=html /p:CoverletOutput=./coverage/

# 查看覆盖率阈值
dotnet test /p:CollectCoverage=true /p:Threshold=85
```

## 性能测试

### 1. 测试执行时间

```csharp
[TestMethod]
public void LookupTableCommand_ExecutePerformance_ShouldCompleteWithinTimeLimit()
{
    // Arrange
    var stopwatch = Stopwatch.StartNew();
    var command = new LookupTableCommand();
    
    // Act
    var result = command.Execute(mockDatabase.Object, "PerformanceTestTable");
    
    // Assert
    stopwatch.Stop();
    Assert.IsTrue(stopwatch.ElapsedMilliseconds < 1000, 
                 $"操作耗时过长: {stopwatch.ElapsedMilliseconds}ms");
}
```

### 2. 内存使用测试

```csharp
[TestMethod]
public void LargeTableProcessing_MemoryUsage_ShouldNotExceedLimit()
{
    // Arrange
    var initialMemory = GC.GetTotalMemory(true);
    var command = new LookupTableCommand();
    var largeTable = TestDataProvider.CreateLargeLookupTable(10000);
    
    // Act
    var result = command.ProcessLargeTable(largeTable);
    
    // Assert
    var finalMemory = GC.GetTotalMemory(false);
    var memoryUsed = finalMemory - initialMemory;
    var memoryLimit = 50 * 1024 * 1024; // 50MB
    
    Assert.IsTrue(memoryUsed < memoryLimit, 
                 $"内存使用超限: {memoryUsed / 1024 / 1024}MB > {memoryLimit / 1024 / 1024}MB");
}
```

## 最佳实践总结

### 1. 测试设计原则
- **单一职责**: 每个测试只验证一个功能点
- **独立性**: 测试之间不应有依赖关系
- **可重复性**: 测试结果应该一致
- **快速执行**: 单元测试应快速完成

### 2. 代码质量要求
- 清晰的测试方法命名
- 适当的注释说明
- 合理的测试数据准备
- 充分的断言验证

### 3. 维护性考虑
- 重构测试代码时的注意事项
- 测试数据的版本管理
- 模拟对象的更新维护

## 常见问题和解决方案

### 1. 测试执行缓慢
- 检查是否有不必要的数据库操作
- 优化模拟对象的创建
- 使用并行测试执行

### 2. 测试不稳定
- 确保测试环境的清理
- 检查异步操作的时序问题
- 验证模拟对象的配置

### 3. 覆盖率不达标
- 识别未测试的代码路径
- 添加边界条件测试
- 测试异常处理逻辑

---

*本指南为ZWDynLookup项目的单元测试提供完整的编写和执行指导，帮助确保代码质量和系统稳定性。*