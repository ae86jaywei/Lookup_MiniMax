---
AIGC:
    ContentProducer: Minimax Agent AI
    ContentPropagator: Minimax Agent AI
    Label: AIGC
    ProduceID: "00000000000000000000000000000000"
    PropagateID: "00000000000000000000000000000000"
    ReservedCode1: 304502202f64b7f740c6bee23be80754e1577ee23fd688b0050c6d07f0ff4bddbf963bfb022100b622d35a86478017c2fe2c8f0c07b55bae166e5f3ecb4d63ac49e80a0f5979e0
    ReservedCode2: 30450220498b82297aefff39830375f4d797b834d8de14ba0a26309a73bdf75867a15248022100a48ead1e81c0e41198a81e0b6eb2fd60ba79dba3b0455f9bda1ff667e5b3f858
---

# 持续集成测试配置指南

## 概述

持续集成(CI)测试是确保ZWDynLookup插件代码质量和功能稳定性的关键环节。本指南详细说明了如何在CI/CD环境中配置、执行和分析测试，确保每次代码变更都能得到及时验证。

## CI/CD架构概览

```
┌─────────────────────────────────────────────────────────────┐
│                    代码仓库 (Git)                           │
├─────────────────────────────────────────────────────────────┤
│  触发器: Push, Pull Request, 定时任务                      │
├─────────────────────────────────────────────────────────────┤
│                    CI/CD 平台                               │
├─────────────────────────────────────────────────────────────┤
│  Azure DevOps  │  GitHub Actions  │  GitLab CI             │
├─────────────────────────────────────────────────────────────┤
│                    测试执行环境                              │
├─────────────────────────────────────────────────────────────┤
│  构建阶段    │  单元测试    │  集成测试  │  部署阶段       │
├─────────────────────────────────────────────────────────────┤
│                    报告和通知                                │
└─────────────────────────────────────────────────────────────┘
```

## Azure DevOps配置

### 1. 项目结构配置

#### azure-pipelines.yml
```yaml
trigger:
  branches:
    include:
    - main
    - develop
    - feature/*
  paths:
    exclude:
    - docs/*
    - README.md

pr:
  branches:
    include:
    - main
    - develop

pool:
  vmImage: 'windows-latest'

variables:
  solution: '**/*.sln'
  buildPlatform: 'x64'
  buildConfiguration: 'Release'
  dotNetFramework: 'net8.0-windows'
  testResultsPath: '$(Build.SourcesDirectory)/TestResults'
  coverageResultsPath: '$(Build.SourcesDirectory)/CoverageResults'

stages:
- stage: Build
  displayName: '构建阶段'
  jobs:
  - job: Build
    displayName: '构建和单元测试'
    
    steps:
    - task: UseDotNet@2
      displayName: '安装 .NET 8.0 SDK'
      inputs:
        packageType: 'sdk'
        version: '8.0.x'
        
    - task: DotNetCoreCLI@2
      displayName: '还原 NuGet 包'
      inputs:
        command: 'restore'
        projects: '$(solution)'
        
    - task: DotNetCoreCLI@2
      displayName: '代码质量检查'
      inputs:
        command: 'format'
        projects: 'ZWDynLookup/ZWDynLookup.csproj'
        arguments: '--verify-no-changes'
        
    - task: DotNetCoreCLI@2
      displayName: '构建项目'
      inputs:
        command: 'build'
        projects: '$(solution)'
        arguments: '--configuration $(buildConfiguration) --no-restore'
        
    - task: DotNetCoreCLI@2
      displayName: '运行单元测试'
      inputs:
        command: 'test'
        projects: 'ZWDynLookup.Tests/ZWDynLookup.Tests.csproj'
        arguments: >
          --configuration $(buildConfiguration) 
          --no-build 
          --collect:"XPlat Code Coverage" 
          --logger trx
          --filter "Category=Unit"
          --ResultsDirectory $(testResultsPath)
          
    - task: PublishTestResults@2
      displayName: '发布单元测试结果'
      condition: succeededOrFailed()
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '$(testResultsPath)/*.trx'
        testRunTitle: 'Unit Tests'
        
    - task: PublishCodeCoverageResults@1
      displayName: '发布代码覆盖率'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'
        reportDirectory: '$(coverageResultsPath)'
        
    - task: SonarCloudPrepare@1
      displayName: 'SonarCloud 分析准备'
      inputs:
        SonarCloud: 'SonarCloud'
        organization: 'your-organization'
        scannerMode: 'MSBuild'
        projectKey: 'ZWDynLookup'
        projectName: 'ZWDynLookup'
        extraProperties: |
          sonar.cs.vstest.reportsPaths=$(testResultsPath)/*.trx
          sonar.coverageReportPaths=$(coverageResultsPath)/coverage.cobertura.xml
          sonar.cs.xunit.reportsPaths=$(testResultsPath)/*.trx

- stage: QualityGate
  displayName: '质量门禁'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: QualityCheck
    displayName: '代码质量检查'
    
    steps:
    - task: SonarCloudAnalyze@1
      displayName: 'SonarCloud 代码分析'
      
    - task: SonarCloudPublish@1
      displayName: '发布 SonarCloud 结果'
      inputs:
        pollingTimeoutSec: '300'

- stage: IntegrationTests
  displayName: '集成测试阶段'
  dependsOn: QualityGate
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: IntegrationTests
    displayName: '集成测试'
    
    steps:
    - task: PowerShell@2
      displayName: '准备 AutoCAD 测试环境'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/setup-test-environment.ps1'
        arguments: '-AutoCADVersion "2024" -InstallPath "$(Agent.TempDirectory)/AutoCAD"'
        
    - task: DotNetCoreCLI@2
      displayName: '运行集成测试'
      inputs:
        command: 'test'
        projects: 'ZWDynLookup.Tests/ZWDynLookup.Tests.csproj'
        arguments: >
          --configuration $(buildConfiguration)
          --filter "Category=Integration"
          --logger trx
          --ResultsDirectory $(testResultsPath)
          
    - task: DotNetCoreCLI@2
      displayName: '运行 UI 测试'
      inputs:
        command: 'test'
        projects: 'ZWDynLookup.Tests/ZWDynLookup.Tests.csproj'
        arguments: >
          --configuration $(buildConfiguration)
          --filter "Category=UI"
          --logger trx
          --ResultsDirectory $(testResultsPath)
          --collect:"XPlat Code Coverage"
          
    - task: PublishTestResults@2
      displayName: '发布集成测试结果'
      condition: succeededOrFailed()
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '$(testResultsPath)/*.trx'
        testRunTitle: 'Integration Tests'

- stage: PerformanceTests
  displayName: '性能测试阶段'
  dependsOn: IntegrationTests
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: PerformanceTests
    displayName: '性能测试'
    
    steps:
    - task: DotNetCoreCLI@2
      displayName: '运行性能测试'
      inputs:
        command: 'test'
        projects: 'ZWDynLookup.Tests/ZWDynLookup.Tests.csproj'
        arguments: >
          --configuration $(buildConfiguration)
          --filter "Category=Performance"
          --logger trx
          --ResultsDirectory $(testResultsPath)
          
    - task: PowerShell@2
      displayName: '生成性能报告'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/generate-performance-report.ps1'
        arguments: '-TestResultsPath "$(testResultsPath)" -OutputPath "$(Build.ArtifactStagingDirectory)"'
        
    - task: PublishTestResults@2
      displayName: '发布性能测试结果'
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '$(testResultsPath)/*.trx'
        testRunTitle: 'Performance Tests'

- stage: SecurityScan
  displayName: '安全扫描'
  dependsOn: QualityGate
  condition: succeeded()
  jobs:
  - job: SecurityScan
    displayName: '安全漏洞扫描'
    
    steps:
    - task: SonarCloudPrepare@1
      displayName: '准备安全扫描'
      inputs:
        SonarCloud: 'SonarCloud'
        organization: 'your-organization'
        scannerMode: 'MSBuild'
        projectKey: 'ZWDynLookup-Security'
        
    - task: SonarCloudAnalyze@1
      displayName: '执行安全扫描'
      
    - task: CredScan@3
      displayName: '凭据扫描'
      inputs:
        toolMajorVersion: 'V3'

- stage: Package
  displayName: '打包发布'
  dependsOn:
  - Build
  - QualityGate
  - IntegrationTests
  - PerformanceTests
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: Package
    displayName: '创建 NuGet 包'
    
    steps:
    - task: DotNetCoreCLI@2
      displayName: '打包 NuGet'
      inputs:
        command: 'pack'
        projects: 'ZWDynLookup/ZWDynLookup.csproj'
        arguments: >
          --configuration $(buildConfiguration)
          --no-build
          --output $(Build.ArtifactStagingDirectory)
          /p:PackageVersion=$(Build.BuildNumber)
          
    - task: NuGetCommand@2
      displayName: '推送到 NuGet'
      inputs:
        command: 'push'
        packagesToPush: '$(Build.ArtifactStagingDirectory)/*.nupkg'
        nuGetFeedType: 'internal'
        publishVstsFeed: 'ZWDynLookup-Packages'
        
    - task: PublishBuildArtifacts@1
      displayName: '发布构建产物'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'packages'
        publishLocation: 'Container'
```

### 2. 质量门禁配置

#### sonar-project.properties
```properties
# SonarCloud 项目配置
sonar.projectKey=ZWDynLookup
sonar.organization=your-organization
sonar.projectName=ZWDynLookup
sonar.projectVersion=1.0

# 源代码配置
sonar.sources=ZWDynLookup
sonar.tests=ZWDynLookup.Tests
sonar.sourceEncoding=UTF-8

# 排除配置
sonar.exclusions=**/bin/**,**/obj/**,**/*.Designer.cs,**/Properties/AssemblyInfo.cs
sonar.test.exclusions=**/TestData/**,**/*.config

# 测试覆盖率配置
sonar.cs.vstest.reportsPaths=TestResults/*.trx
sonar.cs.xunit.reportsPaths=TestResults/*.trx
sonar.coverageReportPaths=CoverageResults/coverage.cobertura.xml

# 质量门禁配置
sonar.qualitygate.wait=true

# 代码规范配置
sonar.cs.roslyn.issueSearchPath=bin
sonar.cs.roslyn.ignoreIssuesReportedOutsideFilesAndModules=true

# 安全配置
sonar.security.hotspots.minScore=0.7
sonar.vulnerabilities.threshold=1

# 重复代码配置
sonar.cpd.exclusions=**/Test*.cs,**/*Tests.cs
```

#### 质量门禁规则
```json
{
  "qualityGate": {
    "name": "ZWDynLookup Quality Gate",
    "conditions": [
      {
        "metric": "coverage",
        "operator": "LT",
        "error": "80",
        "warning": "85"
      },
      {
        "metric": "duplicated_lines_density",
        "operator": "GT",
        "error": "3",
        "warning": "2"
      },
      {
        "metric": "vulnerabilities",
        "operator": "GT",
        "error": "0"
      },
      {
        "metric": "code_smells",
        "operator": "GT",
        "error": "100",
        "warning": "50"
      },
      {
        "metric": "bugs",
        "operator": "GT",
        "error": "0"
      },
      {
        "metric": "security_hotspots",
        "operator": "GT",
        "error": "10"
      }
    ]
  }
}
```

## GitHub Actions配置

### 1. 主要工作流

#### .github/workflows/ci.yml
```yaml
name: 持续集成

on:
  push:
    branches: [ main, develop ]
    paths-ignore: 
      - 'docs/**'
      - 'README.md'
      - '**.md'
  pull_request:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - 'README.md'
      - '**.md'

env:
  DOTNET_VERSION: '8.0.x'
  SOLUTION_PATH: './ZWDynLookup.sln'
  TEST_PROJECT_PATH: './ZWDynLookup.Tests/ZWDynLookup.Tests.csproj'
  COVERAGE_THRESHOLD: 80

jobs:
  code-quality:
    name: 代码质量检查
    runs-on: windows-latest
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: 设置 .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: 缓存 NuGet 包
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.sln') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
          
    - name: 还原依赖
      run: dotnet restore ${{ env.SOLUTION_PATH }}
      
    - name: 代码格式检查
      run: dotnet format --verify-no-changes ${{ env.SOLUTION_PATH }}
      
    - name: 静态代码分析
      run: |
        dotnet tool install --global dotnet-reportgenerator-globaltool
        reportgenerator -reports:**/coverage.cobertura.xml -targetdir:coverage -reporttypes:"HTML_Light"
        
    - name: 上传覆盖率报告
      uses: codecov/codecov-action@v3
      with:
        file: '**/coverage.cobertura.xml'
        flags: unittests
        name: codecov-umbrella

  unit-tests:
    name: 单元测试
    runs-on: windows-latest
    needs: code-quality
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
      
    - name: 设置 .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: 恢复依赖
      run: dotnet restore ${{ env.SOLUTION_PATH }}
      
    - name: 构建
      run: dotnet build ${{ env.SOLUTION_PATH }} --configuration Release --no-restore
      
    - name: 运行单元测试
      run: |
        dotnet test ${{ env.TEST_PROJECT_PATH }} \
          --configuration Release \
          --no-build \
          --collect:"XPlat Code Coverage" \
          --logger trx \
          --filter "Category=Unit" \
          -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura
          
    - name: 上传测试结果
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: unit-test-results
        path: |
          TestResults/
          **/coverage.cobertura.xml
          
    - name: 发布测试结果
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: Unit Test Results
        path: TestResults/*.trx
        reporter: dotnet-trx
        fail-on-error: false

  integration-tests:
    name: 集成测试
    runs-on: windows-latest
    needs: unit-tests
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    services:
      sqlserver:
        image: mcr.microsoft.com/mssql/server:2019-latest
        env:
          ACCEPT_EULA: Y
          SA_PASSWORD: "YourStrong@Passw0rd"
        ports:
          - 1433:1433
        options: --health-cmd="/opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P YourStrong@Passw0rd -Q 'SELECT 1'" --health-interval=10s --health-timeout=5s --health-retries=10
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
      
    - name: 设置 .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: 准备测试环境
      run: |
        # 创建测试数据库
        sqlcmd -S localhost -U sa -P "YourStrong@Passw0rd" -Q "CREATE DATABASE ZWDynLookup_Test"
        
    - name: 运行集成测试
      run: |
        dotnet test ${{ env.TEST_PROJECT_PATH }} \
          --configuration Release \
          --filter "Category=Integration" \
          --logger trx \
          --collect:"XPlat Code Coverage"
          
    - name: 运行UI测试
      run: |
        dotnet test ${{ env.TEST_PROJECT_PATH }} \
          --configuration Release \
          --filter "Category=UI" \
          --logger trx
          
    - name: 上传集成测试结果
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: integration-test-results
        path: TestResults/

  performance-tests:
    name: 性能测试
    runs-on: windows-latest
    needs: integration-tests
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
      
    - name: 设置 .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: 运行性能测试
      run: |
        dotnet test ${{ env.TEST_PROJECT_PATH }} \
          --configuration Release \
          --filter "Category=Performance" \
          --logger trx
          
    - name: 生成性能报告
      run: |
        # 脚本生成性能报告
        powershell -File scripts/generate-performance-report.ps1
        
    - name: 上传性能报告
      uses: actions/upload-artifact@v3
      with:
        name: performance-reports
        path: PerformanceReports/

  security-scan:
    name: 安全扫描
    runs-on: windows-latest
    needs: unit-tests
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
      
    - name: 设置 .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: 运行安全扫描
      uses: github/codeql-action/init@v2
      with:
        languages: csharp
        
    - name: 构建
      run: dotnet build ${{ env.SOLUTION_PATH }} --configuration Release
      
    - name: 执行 CodeQL 分析
      uses: github/codeql-action/analyze@v2

  package:
    name: 打包发布
    runs-on: windows-latest
    needs: 
      - unit-tests
      - integration-tests
      - performance-tests
      - security-scan
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
      
    - name: 设置 .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: 打包
      run: |
        dotnet pack ZWDynLookup/ZWDynLookup.csproj \
          --configuration Release \
          --no-build \
          --output ./artifacts \
          /p:PackageVersion=${{ github.run_number }}
          
    - name: 上传包文件
      uses: actions/upload-artifact@v3
      with:
        name: nuget-packages
        path: artifacts/*.nupkg
        
    - name: 发布到 GitHub Packages
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        dotnet nuget push artifacts/*.nupkg \
          --source https://nuget.pkg.github.com/${{ github.repository_owner }} \
          --api-key ${{ secrets.GITHUB_TOKEN }}
```

### 2. 依赖扫描工作流

#### .github/workflows/dependency-scan.yml
```yaml
name: 依赖安全扫描

on:
  schedule:
    - cron: '0 2 * * 1'  # 每周一凌晨2点
  workflow_dispatch:

jobs:
  dependency-scan:
    name: 依赖漏洞扫描
    runs-on: windows-latest
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
      
    - name: 设置 .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '8.0.x'
        
    - name: 还原依赖
      run: dotnet restore
      
    - name: 运行依赖扫描
      run: |
        dotnet list package --vulnerable --deprecated
        
    - name: 生成依赖报告
      run: |
        dotnet list package --vulnerable --deprecated --format json > dependency-report.json
        
    - name: 上传报告
      uses: actions/upload-artifact@v3
      with:
        name: dependency-report
        path: dependency-report.json
```

## 测试结果分析和报告

### 1. 测试结果聚合

```csharp
public class TestResultsAggregator
{
    public static TestSummaryAggregate AggregateTestResults(string testResultsPath)
    {
        var aggregate = new TestSummaryAggregate();
        var trxFiles = Directory.GetFiles(testResultsPath, "*.trx");
        
        foreach (var trxFile in trxFiles)
        {
            var trxData = ParseTrxFile(trxFile);
            aggregate.AddTestRun(trxData);
        }
        
        return aggregate;
    }
    
    private static TestRunData ParseTrxFile(string filePath)
    {
        var doc = XDocument.Load(filePath);
        var ns = XNamespace.Get("http://microsoft.com/schemas/VisualStudio/TeamTest/2010");
        
        var outcome = doc.Descendants(ns + "Outcome").FirstOrDefault()?.Value ?? "Unknown";
        var total = int.Parse(doc.Descendants(ns + "Counters").First().Attribute("total")?.Value ?? "0");
        var passed = int.Parse(doc.Descendants(ns + "Counters").First().Attribute("passed")?.Value ?? "0");
        var failed = int.Parse(doc.Descendants(ns + "Counters").First().Attribute("failed")?.Value ?? "0");
        
        return new TestRunData
        {
            FileName = Path.GetFileNameWithoutExtension(filePath),
            Outcome = outcome,
            TotalTests = total,
            PassedTests = passed,
            FailedTests = failed,
            Duration = ParseDuration(doc),
            ExecutionDate = ParseExecutionDate(doc)
        };
    }
    
    public static string GenerateHtmlReport(TestSummaryAggregate aggregate)
    {
        var sb = new StringBuilder();
        sb.AppendLine("<!DOCTYPE html>");
        sb.AppendLine("<html><head><title>测试报告</title>");
        sb.AppendLine("<style>");
        sb.AppendLine("body { font-family: Arial, sans-serif; margin: 20px; }");
        sb.AppendLine("table { border-collapse: collapse; width: 100%; }");
        sb.AppendLine("th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }");
        sb.AppendLine("th { background-color: #f2f2f2; }");
        sb.AppendLine(".pass { color: green; font-weight: bold; }");
        sb.AppendLine(".fail { color: red; font-weight: bold; }");
        sb.AppendLine(".summary { background-color: #e7f3ff; padding: 15px; margin: 20px 0; }");
        sb.AppendLine("</style></head><body>");
        
        sb.AppendLine("<h1>ZWDynLookup 测试报告</h1>");
        sb.AppendLine($"<div class='summary'>");
        sb.AppendLine($"<h2>执行摘要</h2>");
        sb.AppendLine($"<p>总测试数: {aggregate.TotalTests}</p>");
        sb.AppendLine($"<p>通过: <span class='pass'>{aggregate.PassedTests}</span></p>");
        sb.AppendLine($"<p>失败: <span class='fail'>{aggregate.FailedTests}</span></p>");
        sb.AppendLine($"<p>成功率: {aggregate.SuccessRate:P2}</p>");
        sb.AppendLine($"<p>总执行时间: {aggregate.TotalDuration:hh\\:mm\\:ss}</p>");
        sb.AppendLine($"</div>");
        
        sb.AppendLine("<h2>详细结果</h2>");
        sb.AppendLine("<table>");
        sb.AppendLine("<tr><th>测试套件</th><th>总数</th><th>通过</th><th>失败</th><th>成功率</th><th>执行时间</th><th>状态</th></tr>");
        
        foreach (var run in aggregate.TestRuns)
        {
            var statusClass = run.Outcome == "Passed" ? "pass" : "fail";
            var successRate = run.TotalTests > 0 ? (double)run.PassedTests / run.TotalTests : 0;
            
            sb.AppendLine($"<tr>");
            sb.AppendLine($"<td>{run.FileName}</td>");
            sb.AppendLine($"<td>{run.TotalTests}</td>");
            sb.AppendLine($"<td class='pass'>{run.PassedTests}</td>");
            sb.AppendLine($"<td class='fail'>{run.FailedTests}</td>");
            sb.AppendLine($"<td>{successRate:P2}</td>");
            sb.AppendLine($"<td>{run.Duration:hh\\:mm\\:ss}</td>");
            sb.AppendLine($"<td class='{statusClass}'>{run.Outcome}</td>");
            sb.AppendLine($"</tr>");
        }
        
        sb.AppendLine("</table></body></html>");
        return sb.ToString();
    }
}

public class TestSummaryAggregate
{
    public List<TestRunData> TestRuns { get; } = new();
    
    public int TotalTests => TestRuns.Sum(r => r.TotalTests);
    public int PassedTests => TestRuns.Sum(r => r.PassedTests);
    public int FailedTests => TestRuns.Sum(r => r.FailedTests);
    public double SuccessRate => TotalTests > 0 ? (double)PassedTests / TotalTests : 0;
    public TimeSpan TotalDuration => TimeSpan.FromTicks(TestRuns.Sum(r => r.Duration.Ticks));
    
    public void AddTestRun(TestRunData testRun)
    {
        TestRuns.Add(testRun);
    }
}
```

### 2. 覆盖率趋势分析

```csharp
public class CoverageTrendAnalyzer
{
    public static CoverageTrend AnalyzeCoverageTrend(string coverageFilesPath)
    {
        var coverageFiles = Directory.GetFiles(coverageFilesPath, "*.cobertura.xml");
        var trend = new CoverageTrend();
        
        foreach (var file in coverageFiles.OrderBy(f => File.GetCreationTime(f)))
        {
            var coverage = ParseCoberturaCoverage(file);
            trend.AddDataPoint(File.GetCreationTime(file), coverage);
        }
        
        return trend;
    }
    
    private static CoverageData ParseCoberturaCoverage(string filePath)
    {
        var doc = XDocument.Load(filePath);
        var coverage = doc.Attribute("line-rate");
        
        var lineRate = coverage != null ? double.Parse(coverage.Value) : 0;
        
        return new CoverageData
        {
            Date = File.GetCreationTime(filePath),
            LineCoverage = lineRate,
            BranchCoverage = ParseBranchCoverage(doc),
            ClassesCovered = ParseClassesCovered(doc)
        };
    }
    
    public static void GenerateCoverageReport(CoverageTrend trend, string outputPath)
    {
        var sb = new StringBuilder();
        sb.AppendLine("# 代码覆盖率趋势报告");
        sb.AppendLine();
        sb.AppendLine("## 覆盖率历史");
        sb.AppendLine();
        sb.AppendLine("| 日期 | 行覆盖率 | 分支覆盖率 | 类覆盖率 | 趋势 |");
        sb.AppendLine("|------|----------|------------|----------|------|");
        
        for (int i = 0; i < trend.DataPoints.Count; i++)
        {
            var point = trend.DataPoints[i];
            var trendIcon = i > 0 ? GetTrendIcon(point.LineCoverage, trend.DataPoints[i - 1].LineCoverage) : "-";
            
            sb.AppendLine($"| {point.Date:yyyy-MM-dd} | {point.LineCoverage:P2} | {point.BranchCoverage:P2} | {point.ClassesCovered} | {trendIcon} |");
        }
        
        sb.AppendLine();
        sb.AppendLine("## 趋势分析");
        sb.AppendLine($"- 当前行覆盖率: {trend.Latest.LineCoverage:P2}");
        sb.AppendLine($"- 平均覆盖率: {trend.Average.LineCoverage:P2}");
        sb.AppendLine($"- 覆盖率变化: {trend.Change:P2}");
        
        File.WriteAllText(outputPath, sb.ToString());
    }
    
    private static string GetTrendIcon(double current, double previous)
    {
        var diff = current - previous;
        if (Math.Abs(diff) < 0.001) return "→";
        return diff > 0 ? "↗" : "↘";
    }
}
```

## 通知和报警机制

### 1. Teams/钉钉通知

```yaml
# 在Azure DevOps中配置通知
- task: PowerShell@2
  displayName: '发送测试结果通知'
  condition: always()
  inputs:
    targetType: 'filePath'
    filePath: 'scripts/send-notification.ps1'
    arguments: >
      -WebhookUrl "$(TeamsWebhookUrl)"
      -BuildNumber "$(Build.BuildNumber)"
      -TestResultsPath "$(testResultsPath)"
      -BuildStatus "${{ variables['Agent.JobStatus'] }}"
```

```powershell
# send-notification.ps1
param(
    [string]$WebhookUrl,
    [string]$BuildNumber,
    [string]$TestResultsPath,
    [string]$BuildStatus
)

function Send-TeamsNotification {
    param(
        [string]$WebhookUrl,
        [string]$Title,
        [string]$Message,
        [string]$Color = "good"
    )
    
    $payload = @{
        "@type" = "MessageCard"
        "@context" = "http://schema.org/extensions"
        "summary" = $Title
        "themeColor" = $Color
        "sections" = @(
            @{
                "activityTitle" = $Title
                "activitySubtitle" = "构建 #$BuildNumber"
                "text" = $Message
            }
        )
    }
    
    Invoke-RestMethod -Uri $WebhookUrl -Method Post -Body ($payload | ConvertTo-Json -Depth 10) -ContentType "application/json"
}

# 分析测试结果
$testResults = Get-ChildItem -Path $TestResultsPath -Filter "*.trx"
$totalTests = 0
$passedTests = 0
$failedTests = 0

foreach ($trxFile in $testResults) {
    $trxData = [xml](Get-Content $trxFile.FullName)
    $counters = $trxData.TestRun.Counters
    
    $totalTests += [int]$counters.total
    $passedTests += [int]$counters.passed
    $failedTests += [int]$counters.failed
}

$successRate = if ($totalTests -gt 0) { ($passedTests / $totalTests * 100) } else { 0 }

# 发送通知
$title = "ZWDynLookup 测试完成"
$color = if ($failedTests -eq 0) { "good" } elseif ($successRate -gt 80) { "warning" } else { "danger" }

$message = @"
测试执行完成:
- 总测试数: $totalTests
- 通过: $passedTests
- 失败: $failedTests
- 成功率: {0:P2}

构建状态: $BuildStatus
"@ -f ($passedTests / $totalTests)

Send-TeamsNotification -WebhookUrl $WebhookUrl -Title $title -Message $message -Color $color
```

### 2. 邮件通知模板

```csharp
public class EmailNotificationTemplate
{
    public static string GenerateTestReportEmail(TestSummaryAggregate aggregate, BuildInfo buildInfo)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("<html><body>");
        sb.AppendLine("<h2>ZWDynLookup 测试报告</h2>");
        sb.AppendLine($"<p><strong>构建编号:</strong> {buildInfo.BuildNumber}</p>");
        sb.AppendLine($"<p><strong>分支:</strong> {buildInfo.Branch}</p>");
        sb.AppendLine($"<p><strong>提交:</strong> {buildInfo.CommitSha.Substring(0, 8)}</p>");
        sb.AppendLine($"<p><strong>执行时间:</strong> {buildInfo.StartTime:yyyy-MM-dd HH:mm:ss}</p>");
        
        sb.AppendLine("<h3>测试摘要</h3>");
        sb.AppendLine("<table border='1' style='border-collapse: collapse;'>");
        sb.AppendLine("<tr><th>指标</th><th>数值</th></tr>");
        sb.AppendLine($"<tr><td>总测试数</td><td>{aggregate.TotalTests}</td></tr>");
        sb.AppendLine($"<tr><td>通过测试</td><td style='color: green;'>{aggregate.PassedTests}</td></tr>");
        sb.AppendLine($"<tr><td>失败测试</td><td style='color: red;'>{aggregate.FailedTests}</td></tr>");
        sb.AppendLine($"<tr><td>成功率</td><td>{aggregate.SuccessRate:P2}</td></tr>");
        sb.AppendLine("</table>");
        
        sb.AppendLine("<h3>质量门禁</h3>");
        var qualityGateStatus = aggregate.FailedTests == 0 ? "通过" : "失败";
        var qualityGateColor = aggregate.FailedTests == 0 ? "green" : "red";
        sb.AppendLine($"<p style='color: {qualityGateColor}; font-weight: bold;'>质量门禁: {qualityGateStatus}</p>");
        
        sb.AppendLine("</body></html>");
        
        return sb.ToString();
    }
}
```

## 故障处理和回滚策略

### 1. 测试失败处理

```yaml
# 在Azure DevOps中配置故障处理
- task: PowerShell@2
  displayName: '处理测试失败'
  condition: failed()
  inputs:
    targetType: 'filePath'
    filePath: 'scripts/handle-test-failures.ps1'
    arguments: '-TestResultsPath "$(testResultsPath)" -BuildNumber "$(Build.BuildNumber)"'

- task: PowerShell@2
  displayName: '生成失败分析报告'
  condition: failed()
  inputs:
    targetType: 'filePath'
    filePath: 'scripts/generate-failure-analysis.ps1'
    arguments: '-TestResultsPath "$(testResultsPath)" -OutputPath "$(Build.ArtifactStagingDirectory)/failure-analysis.html"'
```

### 2. 自动回滚触发

```yaml
# 回滚策略配置
- stage: Rollback
  displayName: '回滚检查'
  dependsOn: Package
  condition: and(failed(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: CheckRollbackCondition
    displayName: '检查回滚条件'
    
    steps:
    - task: PowerShell@2
      displayName: '分析失败原因'
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/analyze-rollback-condition.ps1'
        arguments: '-TestResultsPath "$(testResultsPath)" -BuildNumber "$(Build.BuildNumber)"'
        
    - task: PowerShell@2
      displayName: '执行回滚'
      condition: and(eq(variables['RollbackRequired'], 'true'), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
      inputs:
        targetType: 'filePath'
        filePath: 'scripts/rollback-deployment.ps1'
        arguments: '-PreviousVersion "$(PreviousBuildNumber)" -Environment "Production"'
```

---

*本指南为ZWDynLookup项目提供了完整的CI/CD测试配置框架，确保代码质量和自动化部署的可靠性。*